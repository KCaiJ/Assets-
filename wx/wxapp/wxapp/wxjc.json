{"title": "微信小程序开发，如何优雅地兼容 ", "author": "Rolan", "pub_time": "2018-9-19 00:02", "content": "关于单个 API 如何兼容，微信官方提供了兼容文档，因此我们这里不再赘述。下面主要讨论在整个项目如何优雅地处理兼容问题。问题如果在每处需要兼容的地方都写上一堆兼容相关的代码，随着代码量增加，会出现以下问题：代码难以阅读兼容方案有变动时，需要改动多处随着时间推移，你的代码才是最需要并且是最难兼容的思考最理想的情况是不需要任何兼容处理，因此可以反推出兼容性处理的代码并不是代码正常流程中的一部分，基于此：兼容的细节不必暴露兼容的方案应该统一兼容的方案可方便地变动解决方案1.将兼容方案隐藏，对外提供接口即可比如 wx.showLoading 是在 1.1.0 版本之后才提供的，对于之前的版本需要兼容。我们选择将其放在 show-loading.js 中，内部进行兼容性相关处理，并对外提供 showLoading 方法。这样调用者只需调用 showLoading 方法即可，不用考虑兼容性的问题，而且如果兼容的方式有变动，只需改动 show-loading.js 一处即可。2.兼容的处理还有共性可以抽象兼容处理多了之后我们会发现，对兼容所做的处理无非两方面：支持该方法时，直接使用对应方法不支持该方法时，做一些兼容处理因此这种模式我们又可以抽离出来，这样做当然有一些好处：减少重复代码做一些共性的处理时，我们又只用改动一处（比如当不兼容官方 API 时加上对应统计，用于分析当前应用跨版本的情况）比如我们抽离出这样一个简单的 compatible.js 用于处理兼容时的共性问题：之前的 showLoading.js 我们可以这样写：简单吧 :)，这种写法的意思是兼容时正常展示 loading 即可，不兼容时则不展示。当然可能有完美主义者会觉得『怎么能不展示呢？我就是要展示！』 那么我们可以这样写：用 wx.showToast 伪造了一个 showLoading。3.文件组织兼容性的文件可能会越来越多，对于我这种有收拾的人，看到所有东西散乱地扔在一个抽屉里肯定是不能忍的...因此我们可以多用几个小盒子把它们分门别类地装起来。小盒子怎么选呢？其实官方已经给出了答案，官方 API 是按照不同的功用分组的，因此我们拿分组当『盒子』即可。最终的文件组织像这样："}
{"title": "小程序·云开发初级FAQ ", "author": "Rolan", "pub_time": "2018-10-30 00:23", "content": "之前参加过小程序·云开发相关的分享, 在团队内进行了推广, 感觉官方的宣传不够直接, 还是太玄乎了, 这是收集了猫眼娱乐前端工程师的问题, 和相关答疑, 部分问题是和小程序·云开发的同学沟通过的结论主要面向初级前端工程师, 快速了解云开发是怎么回事, 不涉及复杂代码有小程序开发经验理解 server 端基础, 并有少量node.js server端经验1. 小程序云开发是什么?官方文档, 不用着急点, 下面FAQ未提及的可以进来看主要提供两种能力1.1 提供持久存储持久存储是指删除微信或更换手机后, 用户重新打开我们的小程序, 仍旧能让用户看到自己的信息主要通过两种存储容器类mangodb的 数据库存储 , 比如用户提交的文章文件存储 , 比如用户上传的照片1.2 提供简化的server端编程环境云函数简单解释: 在小程序端写上函数名 + 参数, 就能调用远端的一个函数为什么不直接写到小程序端, 而要绕弯子要这样? 最常见的原因是:有些业务逻辑涉及 保密信息 , 不能写在小程序上, 比如: 价格计算, 交易流程有些操作需要 更高的权限 , 比如: 管理员可以删除所有用户的数据.桥接到第三方接口, 小程序https接口域名数量超限, 或者第三方接口不是https接口.2. 直接操作数据库会不会有安全问题云开发的数据库和传统数据库有些区别, 他会自动给每个数据表增加一个 创建人字段 + 表权限设置 , 后续的操作都会基于这些约束, 一般的策略是每个用户只能修改自己创建的信息, 比如自己发的文章每个用户只能读取其他用户的信息, 但不能修改, 比如其他人发的文章每个用户只能读取公共信息, 但不能修改, 比如公告信息, 一般会允许通过管理端修改3. 直接操作文件存储会不会有安全风险类似上一个数据库的权限, 通过 文件创建人 + 文件夹权限设置文件的操作使用服务端生成的唯一ID, 不会被穷举4. 别人会不会调用我的云函数不会, 云函数的网络协议是私有的, 并且有加上数字签名验证这套机制是在微信app内部实现的, 除非微信这套机制被攻破5.云函数是用js写么, 运行环境是什么?是js, 运行环境是nodejs 8.9, 支持async await关键字目前还不支持修改运行环境, 未来应该会支持自选环境6. 使用了云开发, 是不是就不能使用自己的服务端了不是, 两个可以并存, 就当是看起来不一样的异步调用就好// 云开发相关api\r\nwx.cloud.xxxx()\r\n\r\n// 自有服务\r\nwx.request()\r\n复制代码由于是nodejs的运行环境, 所以云函数可以使用http tcp模块, 这样就能通过云函数转发请求到任意域名, 不受小程序端的请求域名限制7. 典型的云函数是什么样的?// 小程序端, 调用\r\nwx.cloud.callFunction({\r\n    name: 'foo',\r\n    data: { a: 1, b: 2 },\r\n    success: function(res) {\r\n        console.log(res.result)\r\n    }\r\n)\r\n\r\n// 云函数, 声明\r\n// cloudfunctionRoot/functions/foo/index.js\r\nexports.main = async function(e, ctx) {\r\n    return e.a + e.b\r\n}\r\n复制代码函数名和目录名对应, 根路径在project.config.json中定义, 详细参考官方文档中的\"我的第一个云函数\"8. 云函数还有什么特殊能力?直接获取用户的openId// index.js\r\nexports.main = (event, context) => {\r\n  return event.userInfo\r\n}\r\n复制代码如要获取用户头像 昵称等信息, 还是需要在小程序端进行授权才行9. 云函数需要我们考虑服务器运维的工作么不需要, 只要开发好上传就行, 运行环境是独立 封闭的, 类 CentOS 7 的环境10. 开发时和线上环境有隔离么提供1个生产环境, 和1个开发环境, 存储和云函数都是独立的这意味着多个开发者并行开发协作可能会有些小麻烦, 同时只能有一套代码在开发环境, 这就只能通过一些工作流程约定, 比如收敛上传权限, 每日自动部署. 应用类似git-flow的分支策略11. 云开发是否提供有定位 地理信息 支付相关业务的支持暂时没有, 这方面的需求还是很强的, 毕竟小程序是提倡线下扫码, 扫码后还是期望能够获取到附近的相关信息, 简单的比如城市 区划, 详细的比如商家小程序云开发的同学目前还在收集这方面的需求12. 什么版本的基础库支持云开发基础库 2.2.3 之后开始支持, 但对于旧版本可以加个配置也能支持app.json/game.json{\r\n  \"cloud\": true\r\n}\r\n复制代码13. 费用呢目前免费, 正在调研计费策略, 可能是按照调用量, 存储量计费netwjx曹宇   https://juejin.im/post/5bcd5df7518825780d09b145"}
{"title": "微信小程序多层嵌套循环，三级数组遍历 ", "author": "Rolan", "pub_time": "2018-10-30 00:32", "content": "数据：三层嵌套index.wxml 页面<!-- 菜单标签 -->\r\n<view class='menu_label'>\r\n    <view class='label_ul'>\r\n        <view wx:for=\"{{ menuList }}\" wx:key='' class=\"{{ label_index == index ? 'label_lis' : 'label_li' }}\" bindtap='menuList' id=\"{{ index }}\">{{ item.title }}</view>\r\n    </view>\r\n</view>\r\n\r\n<!-- 图书内容 -->\r\n<view class='book_sec'>\r\n    <view class='book_ul' wx:for=\"{{ bookUl }}\" wx:key='' wx:for-item=\"secUl\"  wx:if=\"{{ label_index == index }}\" id=\"{{ index }}\">\r\n        <view class='book_li' wx:for='{{ secUl.bookSec }}' wx:key='' wx:for-item=\"secLi\">\r\n            <view class='book_ol'>\r\n                <view class='book_ol_li' wx:for='{{ secLi.bookList }}' wx:key='' wx:for-item=\"item\">\r\n                    <view class='book_free b'>免费阅读</view>\r\n                    <image src='{{ item.img }}'></image>\r\n                    <view class='book_people b'>100006人在读</view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n    </view>\r\n</view>\r\n\r\n\r\nindex.js页面Page({\r\n        /**\r\n         * 页面的初始数据\r\n         */\r\n        data: {\r\n            menuList: [\r\n                { title: '全部' },\r\n                { title: '文学' },\r\n                { title: '技术类' },\r\n                { title: '社会科学' },\r\n                { title: '设计' },\r\n                { title: '技术类' },\r\n                { title: '社会科学' },\r\n            ],\r\n            label_index: 0,\r\n            bookUl: [\r\n                {\r\n                    bookSec: [\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img1_icon.png' },\r\n                                { img: '../../img/img2_icon.png' },\r\n                                { img: '../../img/img3_icon.png' },\r\n                            ]\r\n                        },\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img4_icon.png' },\r\n                                { img: '../../img/img5_icon.png' },\r\n                            ]\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    bookSec: [\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img6_icon.png' },\r\n                                { img: '../../img/img5_icon.png' },\r\n                                { img: '../../img/img4_icon.png' }\r\n                            ]\r\n                        },\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img7_icon.png' }\r\n                            ]\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    bookSec: [\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img7_icon.png' },\r\n                                { img: '../../img/img2_icon.png' },\r\n                                { img: '../../img/img1_icon.png' },\r\n                            ]\r\n                        },\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img3_icon.png' },\r\n                                { img: '../../img/img4_icon.png' },\r\n                                { img: '../../img/img6_icon.png' }\r\n                            ]\r\n                        }\r\n                    ]\r\n                },\r\n            ]\r\n            \r\n            /**\r\n             * 菜单点击切换内容\r\n             */\r\n        \r\n            menuList: function (e) {\r\n                let that = this;\r\n                // console.log(e);\r\n                var id = e.target.id;\r\n                \r\n                that.setData({\r\n                    label_index: id\r\n                })\r\n            } \r\n        },\r\n    })\r\n\r\n如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <input/> 中的输入内容，<switch/> 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。wx:key 的值以两种形式提供1）字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。2）保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。最后效果图作者：MRZYD原文：https://segmentfault.com/a/1190000016818075"}
{"title": "小程序tabbar这套方案全搞定！ ", "author": "Rolan", "pub_time": "2018-10-31 00:12", "content": "关于微信小程序的tarbar，相信你们都不会陌生 在实现小程序微信原装的tabbar却比较呆板，不够精致，往往不符合自己的要求这个时候怎么办呢这套方案接着！先简单的来说一下主要思想:自定义字体图标组件以及tabbar组件，在tabbar中引用自定义字体图标组件。先说一下这套方案的优点：图片换成字体,体积小,请求减少,性能提高自己定义tabbar,能够从细节各方面达到自己的要求，精确到1像素组件可以根据自己的条件来更换tabbar图标（比如你点进一个页面想把这个页面的tabbar样式自己更换） 总而言之就是自由性很大，精准性良好，能够去随心所欲的打造你的专属tabbar!实现这套方案核心还是自定义组件那就从这开始聊：一个自定义组件由 json wxml wxss js 4个文件组成。一个页面要引用一个组件时只需要在该页面的json配置下添加如下{\r\n//声明引用一个组件 配置好你的组件引用路径\r\n  \"usingComponents\": {\r\n    \"icon\": \"../../components/icon/index\"\r\n  }\r\n}\r\n复制代码然后再页面上添加组件的标签即可。//这样就能够在你的页面中添加组件\r\n<icon type=\"\" color=\"\" size=\"\"/>\r\n复制代码如果对于组件的定义仍有疑惑的可以参考这份文档： 官方关于自定义组件的文档OK 下面我们正式来讲这份方案：先定义字体图标组件，在阿里图标库里面挑选好你所需要的字体选择下载代码。 这里我选择的是其中的_fontclass方案，把iconfont.css内的内容拷贝到你创建的icon目录下的index.wxss3. 将该目录下index.json添加{  \r\n//声明这一组文件设为自定义组件\r\n  \"component\": true,\r\n  \"usingComponents\": {}\r\n}\r\n复制代码在index.wxml中定义该组件的结构<!-- 注意style里面的分号！ -->\r\n<text class=\"iconfont icon-{{type}}\" style=\"color:{{color}}; font-size:{{size}}rpx\" ></text>\r\n复制代码在js里面配置他的属性//这里定义了3个自定义属性他们通过{{}}与wxml中的数据连接起来\r\n Component({\r\n  properties: {\r\n    type: {\r\n      type: String,\r\n      value: ''\r\n    },\r\n    color: {\r\n      type: String,\r\n      value: '#000000'\r\n    },\r\n    size: {\r\n      type: Number,\r\n      value: '45'\r\n    }\r\n  }\r\n})\r\n复制代码到此，字体图标组件搞定。现在开始第二步，搞定tabbar组件。首先做在json中添加配置{\r\n  \"component\": true,\r\n  //声明对字体图标组件的引用\r\n  \"usingComponents\": {\r\n    \"icon\": \"../../components/icon/index\"\r\n  }\r\n}\r\n复制代码写wxml结构<view class=\"weibo-tabbar\" >\r\n//绑定回首页事件，此处的data-hi中的数据是为了传递到e.currentTarget.dataset.hi\r\n//通过这个数据我们可以用来判断是否处于首页，然后在js中配置可以阻扰原地跳转\r\n    <view class=\"item-left\"  bindtap=\"goHome\" data-hi=\"{{isIndex}}\">\r\n            <icon type=\"shouye\" color=\"{{isIndex?'#000000':'#b1b1b1'}}\" size=\"45\"/>\r\n            <text class=\"1\" style=\"color:{{isIndex?'#000000':'#b1b1b1'}}\">首页</text>\r\n    </view>\r\n    <block wx:if=\"{{isInner}}\">\r\n        <view class=\"item-right\" style=\"color:#b1b1b1\" bindtap=\"goShare\">\r\n        <icon type=\"fenxiang\" color=\"gray\" size=\"45\"/>\r\n            <text class=\"2\">分享</text>\r\n        </view>\r\n    </block>\r\n    <block wx:else>\r\n        <view class=\"item-right\"  bindtap=\"goInfo\" data-hi=\"{{isIndex}}\">\r\n        <icon type=\"wode\" color=\"{{isIndex?'#b1b1b1':'#000000'}}\" size=\"45\"/>\r\n            <text class=\"2\" style=\"color:{{isIndex?'#b1b1b1':'#000000'}}\">我的</text>\r\n        </view>\r\n    </block>\r\n</view>\r\n复制代码再配置js属性及方法const app = getApp();\r\nComponent({\r\n  properties: {\r\n    isIndex: { // 是否主页            \r\n      type: Boolean,\r\n      value: false,\r\n    },\r\n    isInner: { //是否内部页面\r\n      type: Boolean,\r\n      value: false,\r\n    },\r\n  },\r\n  data: {\r\n    // 这里是一些组件内部数据\r\n    someData: {}\r\n  },\r\n  methods: {\r\n    // 这里是一个自定义方法\r\n    goHome: (e) => {\r\n      // 判断是否为主页面防止原地跳转\r\n      if(!e.currentTarget.dataset.hi){\r\n        wx.redirectTo({\r\n          url: \"/pages/index/index\"\r\n        })\r\n      }\r\n    },\r\n    goShare: function () {\r\n    },\r\n    goInfo: (e) => {\r\n        if(e.currentTarget.dataset.hi){\r\n        wx.redirectTo({\r\n          url: \"/pages/info/info\"\r\n        })\r\n      }\r\n    }\r\n  }\r\n})\r\n复制代码配置样式wxss.weibo-tabbar {\r\n    bottom: 0;\r\n    height: 97rpx;\r\n    padding: 12rpx 0rpx;\r\n    display: flex;\r\n    width: 100%;\r\n    position: fixed;\r\n    background: #ffffff;\r\n    box-sizing: border-box;\r\n}\r\n//产生优雅的0.5px边框\r\n.weibo-tabbar::after {\r\n    content: \"\";\r\n    position: absolute;\r\n    width: 200%;\r\n    height: 200%;\r\n    top: 0;\r\n    left: 0;\r\n    border-top: 1rpx solid rgba(177, 177, 177, 0.4);\r\n    transform: scale(0.5);\r\n    transform-origin: 0 0;\r\n  }\r\n  //这里用flex布局，移动端flex布局确实很爽\r\n  .weibo-tabbar .item-left, .item-right{\r\n   //这里有一处坑，若不不设置他的层级变大的话\r\n   //你是点不到这个item按钮的，当然也不会产生触碰事件\r\n    z-index: 999;\r\n    width: 50%;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    flex-direction: column;\r\n    font-size: 20rpx;\r\n    color: #b1b1b1;\r\n}\r\n.shouye, .wode {\r\n    height: 45rpx;\r\n    width: 45rpx;\r\n}\r\n复制代码到此你只需要在你的页面优雅的添加一行，就能在你的页面中产生tabbar//此处isIndex是给组件的属性传输值，别属性不添加即为默认属性值\r\n<tabbar isIndex=\"true\"></tabbar>\r\n复制代码结果：哇，看了半天就出这么一个小东西！其实大道至简掌握这套方案能够适配你需要的所有tabbar他的颜色、大小、位置都可以自己掌控，重要的是这个解决方案。最后强调一下里面的一些坑按钮的样式层级z-index要提高属性值与{{}}传输的把握style=\"color:{{color}}; font-size:{{size}}\" 注意里面的;号"}
{"title": "微信小程序之animation底部弹窗动画（两种方法） ", "author": "Rolan", "pub_time": "2018-10-31 00:26", "content": "简单分享一下常用的底部弹窗层或下拉框弹出层（代码需要修改）的内容弹窗的动画效果，这里分享的是点击按钮后底部弹窗的动画效果。第一种方式是动态设置显示区域的高度，第二种方法是动态设置显示区域的移动的位置（使用到 transform:translateY ）；（一）实现效果简单说明一下，两种方法实现的效果是一样的，只有点击按钮才能出发弹窗（指定位置），弹窗弹出后，只有点击背景灰色区域弹窗才能收回，点击弹窗内容区域（粉红色部分是不能收回弹窗的），自己可以自定义粉红色部分右上角关闭按钮。（二）实现分析第一种动态设置高度的方法是：需要一个容器为背景色（灰色区域），一个容器为弹窗内容（粉红色区域），两者是独立的，实现的原理是一样的；粉红色区域的话，就是设置好绝对位置（在屏幕的底部）和默认内容的区域样式，动态设置内容区域的高度，比如弹出：一开始高度为0（隐藏了），通过animation设置的动画时间，将高度从0到指定高度，内容慢慢就会显示了，然后保留最后一帧的动画样式就行了；收缩也是一样的道理。第二种动态设置位置的方法是：需要一个容器为背景色（灰色区域），一个容器为弹窗内容（粉红色区域），两者是独立的，实现的原理是一样的；粉红色区域的话，就是设置好绝对位置（在屏幕的底部）和默认内容的区域样式，比如弹出：一开始粉红色区域的位置平移在屏幕外（隐藏了），通过animation设置的动画时间，将粉红色区域从屏幕外平移到屏幕内（默认设置在屏幕底部的位置），内容慢慢就会显示了，然后保留最后一帧的动画样式就行了；收缩也是一样的道理。 代码也有注释哈。（三）实现代码第一种动态设置高度方法实现：1、wxml代码：<button catchtap='clickPup'>点击底部动画弹窗</button>\r\n\r\n<!-- 底部弹窗动画的内容 -->\r\n<view class='pupContent {{click? \"showContent\": \"hideContent\"}} {{option? \"open\": \"close\"}}' hover-stop-propagation='true'>\r\n  <view class='pupContent-top'>测试一下</view>\r\n</view>\r\n<!-- 固定的背景 -->\r\n<view class='pupContentBG {{click?\"showBG\":\"hideBG\"}} {{option?\"openBG\":\"closeBG\"}}' catchtap='clickPup'>\r\n</view>\r\n复制代码2、wxss代码：.pupContentBG {\r\n  width: 100vw;\r\n  height: 100vh;\r\n  position: fixed;\r\n  top: 0;\r\n}\r\n\r\n.pupContent {\r\n  width: 100%;\r\n  background: pink;\r\n  position: absolute;\r\n  bottom: 0;\r\n  box-shadow: 0 0 10rpx #333;\r\n  height: 0;\r\n  z-index: 999;\r\n}\r\n\r\n/* 设置显示的背景 */\r\n\r\n.showBG {\r\n  display: block;\r\n}\r\n\r\n.hideBG {\r\n  display: none;\r\n}\r\n\r\n/* 弹出或关闭动画来动态设置内容高度 */\r\n\r\n@keyframes slideBGtUp {\r\n  from {\r\n    background: transparent;\r\n  }\r\n\r\n  to {\r\n    background: rgba(0, 0, 0, 0.1);\r\n  }\r\n}\r\n\r\n@keyframes slideBGDown {\r\n  from {\r\n    background: rgba(0, 0, 0, 0.1);\r\n  }\r\n\r\n  to {\r\n    background: transparent;\r\n  }\r\n}\r\n\r\n/* 显示或关闭内容时动画 */\r\n\r\n.openBG {\r\n  animation: slideBGtUp 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n.closeBG {\r\n  animation: slideBGDown 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n/* 设置显示内容 */\r\n\r\n.showContent {\r\n  display: block;\r\n}\r\n\r\n.hideContent {\r\n  display: none;\r\n}\r\n\r\n/* 弹出或关闭动画来动态设置内容高度 */\r\n\r\n@keyframes slideContentUp {\r\n  from {\r\n    height: 0;\r\n  }\r\n\r\n  to {\r\n    height: 800rpx;\r\n  }\r\n}\r\n\r\n@keyframes slideContentDown {\r\n  from {\r\n    height: 800rpx;\r\n  }\r\n\r\n  to {\r\n    height: 0;\r\n  }\r\n}\r\n\r\n/* 显示或关闭内容时动画 */\r\n\r\n.open {\r\n  animation: slideContentUp 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n.close {\r\n  animation: slideContentDown 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n复制代码3、js代码：data: {\r\n    click: false, //是否显示弹窗内容\r\n    option: false, //显示弹窗或关闭弹窗的操作动画\r\n  },\r\n\r\n  // 用户点击显示弹窗\r\n  clickPup: function() {\r\n    let _that = this;\r\n    if (!_that.data.click) {\r\n      _that.setData({\r\n        click: true,\r\n      })\r\n    }\r\n\r\n    if (_that.data.option) {\r\n      _that.setData({\r\n        option: false,\r\n      })\r\n\r\n      // 关闭显示弹窗动画的内容，不设置的话会出现：点击任何地方都会出现弹窗，就不是指定位置点击出现弹窗了\r\n      setTimeout(() => {\r\n        _that.setData({\r\n          click: false,\r\n        })\r\n      }, 500)\r\n\r\n\r\n    } else {\r\n      _that.setData({\r\n        option: true\r\n      })\r\n    }\r\n  },\r\n\r\n复制代码第二种动态平移内容区域位置方法实现：相对于第一种代码修改的部分：只修改的了粉红色区域的高度和粉红色区域弹出和收回的动画效果：/* 弹出或关闭动画来动态设置内容高度 */\r\n\r\n@keyframes slideContentUp {\r\n  from {\r\n    transform: translateY(100%); /*设置为正数则底部弹出来，负数则相反*/\r\n  }\r\n\r\n  to {\r\n    transform: translateY(0%);\r\n  }\r\n}\r\n\r\n@keyframes slideContentDown {\r\n  from {\r\n    transform: translateY(0%);\r\n  }\r\n\r\n  to {\r\n    transform: translateY(100%);\r\n  }\r\n}\r\n复制代码参考资料：CSS3（三）Animation 入门详解微信小程序CSS3动画下拉菜单感谢阅读。"}
{"title": "小程序的全栈开发新时代 ", "author": "Rolan", "pub_time": "2018-10-31 00:46", "content": "本文由heyli发表于云+社区专栏什么是小程序·云开发小程序·云开发是微信团队和腾讯云团队共同研发的一套小程序基础能力，简言之就是：云能力将会成为小程序的基础能力。整套功能是基于腾讯云全新推出的 云开发(Tencent Cloud Base)所研发出来的一套完备的小程序后台开发方案。小程序·云开发为开发者提供完整的云端流程，简化后端开发和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代。该解决方案目前提供三大基础能力支持：存储：在小程序前端直接上传/下载云端文件，在小程序云控制台可视化管理数据库：一个既可在小程序前端操作，也能在云函数中读写的文档型数据库云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写业务逻辑代码未来，我们还会集成更多的服务能力，为小程序提供更强有力的云端支持。如何使用小程序·云开发上面就是小程序·云开发简单的使用图谱：在小程序端，直接用官方提供的接口，在云函数端，直接用官方提供的 Node SDK，就可以操作你云的资源。以前开发小程序所担忧的数据库搭建、文件系统部署，通通没有。你只需要有在小程序开发 IDE 里面的 云开发 ，开通一下，填写环境 ID ，便可以拥有小程序的云能力！当然，其实用云开发，并不排斥原有的后台架构，通过下面的架构，你也可以无缝与原有的后台服务兼容，也简化了一些小程序鉴权的逻辑：接下来，我会分别从小程序端、服务端讲述如何使用这些云资源。使用云能力小程序端客户端，这里是指在小程序端中。如果要使用云开发能力，请做以下配置：在 app.json / game.json 中， 中增加字段 \"cloud\": trueproject.config.json 中增加了字段 cloudfunctionRoot 用于指定存放云函数的目录初始化云开发能力：//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    wx.cloud.init({\r\n        traceUser: true // 用户信息会显示在云开发控制台的用户面板中\r\n    });\r\n  }\r\n});小程序端初始化能力文档在用户管理中会显示使用云能力的小程序的访问用户列表，默认以访问时间倒叙排列，访问时间的触发点是在小程序端调用 wx.cloud.init 方法，且其中的 traceUser 参数传值为 true 。服务端如果你想在云函数中，操作文件、数据库和云函数资源，你可以使用我们提供的服务端 SDK 进行操作。首先，进入到你的某个云函数中，安装以下依赖包：npm i --save tcb-admin-node在云函数中初始化// 初始化示例\r\nconst app = require('tcb-admin-node');\r\n\r\n// 初始化资源\r\n// 云函数下不需要secretId和secretKey。\r\n// env如果不指定将使用默认环境\r\napp.init({\r\n  secretId: 'xxxxx',\r\n  secretKey: 'xxxx', \r\n  env: 'xxx'\r\n});\r\n\r\n//云函数下使用默认环境\r\napp.init()\r\n\r\n//云函数下指定环境\r\napp.init({\r\n  env: 'xxx'\r\n});服务端初始化文档存储云开发提供存储空间、上传文件、下载文件、CDN加速文件访问等能力,开发者可以在小程序端与服务端通过 API 使用这些能力。小程序端// 选择图片\r\nwx.chooseImage({\r\n    success: dRes => {\r\n        // 上传图片\r\n        const uploadTask = wx.cloud.uploadFile({\r\n            cloudPath: `${Date.now()}-${Math.floor(Math.random(0, 1) * 10000000)}.png`, // 随机图片名\r\n            filePath: dRes.tempFilePaths[0], // 本地的图片路径\r\n            success: console.log,\r\n            fail: console.error\r\n        });\r\n    },\r\n    fail: console.error,\r\n});小程序端存储文档服务端const app = require('tcb-admin-node');\r\napp.init();\r\n\r\napp.uploadFile({\r\n    cloudPath: \"cover.png\",\r\n    fileContent: fs.createReadStream(`${__dirname}/cover.png`)\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});;控制台上传好的文件，就会出现在控制台中，如下图。你可以在控制台里删除、下载或者查看图片的详情。你还可以控文件整体的权限，这里还有一些具体的介绍。服务端存储文档数据库小程序云提供文档型数据库 ( document-oriented database )，数据库包含多个集合（相当于关系型数据中的表），集合近似于一个 JSON 数组，数组中的每个对象就是一条记录，记录的格式是 JSON 文档。每条记录都有一个 _id 字段用以唯一标志这条记录、一个 _openid 字段用以标志记录的创建者，即小程序的用户。开发者可以自定义 _id ，但不可在小程序端自定义（在服务端可以） _openid 。 _openid 是在文档创建时由系统根据小程序用户默认创建的，开发者可使用其来标识和定位文档。数据库 API 分为小程序端和服务端两部分，小程序端 API 拥有严格的调用权限控制，开发者可在小程序内直接调用 API 进行非敏感数据的操作。对于有更高安全要求的数据，可在云函数内通过服务端 API 进行操作。云函数的环境是与客户端完全隔离的，在云函数上可以私密且安全的操作数据库。数据库 API 包含增删改查的能力，使用 API 操作数据库只需三步：获取数据库引用、构造查询/更新条件、发出请求。切记，在操作数据库前，请先在控制台中创建 collection 。小程序端const db = wx.cloud.database();\r\n\r\n// 插入数据\r\ndb.collection('photo').add({\r\n    data: {\r\n        photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n        title: '风景'\r\n    }\r\n});\r\n\r\n// 提取数据\r\ndb.collection('photo').get().then((res) => {\r\n    let data = res.data;\r\n    console.log(data);\r\n});\r\n\r\n// 输出\r\n// 在小程序端， _openid 会自动插入到数据库中\r\n{\r\n    photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n    title: '风景',\r\n    _openid: 'oLlMr5FICCQJV-QgVLVzKu1212341'\r\n}小程序端数据库文档服务端const app = require('tcb-admin-node');\r\napp.init();\r\nconst db = app.database();\r\n\r\ndb.collection('photo').limit(10).get().then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});\r\n\r\n// 输出\r\n// 因为是在服务端，其它用户的也可以提取出来\r\n{\r\n    photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n    title: '风景',\r\n    _openid: 'oLlMr5FICCQJV-QgVLVzKu1342121'\r\n}\r\n{\r\n    photo: 'cloud://tcb-xxx/0dc3e66fd6b53641e328e091ccb3b9c4e53874232e6bf-ZxSfee_fw658.jpg',\r\n    title: '美女',\r\n    _openid: 'DFDFEX343xxdf-QgVLVzKu12452121'\r\n}\r\n{\r\n    photo: 'cloud://tcb-xxx/104b27e339bdc93c0da15a47aa546b6e9c0e3359c315-L8Px2Y_fw658.jpg',\r\n    title: '动物',\r\n    _openid: 'DFDFEX343xxdf-QgVLVzKu1342121'\r\n}服务端数据库文档控制台可以在控制台里，看到用户操作的数据，你也可以自己在控制台上添加、更新或删除数据。如果数据量庞大，可以设置索引提供查询的效率。数据库也可以通过设置权限，管控每个 collection 。云函数云函数是一段运行在云端的代码，无需管理服务器，在开发工具内一键上传部署即可运行后端代码。开发者可以在云函数内获取到每次调用的上下文（ appid 、 openid 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（ openid ）。小程序端wx.cloud.callFunction({\r\n    name: 'addblog', // 云函数名称\r\n    data: { // 传到云函数处理的参数\r\n        title: '云开发 TCB',\r\n        content: '存储、数据库存、云函数'\r\n    }\r\n}).then(res => {\r\n    console.log(res)\r\n}).catch((err) => {\r\n    console.error(err);\r\n});小程序端云函数文档服务端const app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\napp.callFunction({\r\n    name: 'addblog', // 云函数名称\r\n    data: { // 传到云函数处理的参数\r\n        title: '云开发 TCB',\r\n        content: '存储、数据库存、云函数'\r\n    }\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});服务端云函数文档控制台上传好之后的云函数，都会在这里罗列出来。每次调用云函数，都可以在这里看到日志，还可以构造测试的参数，用于调试。语法糖大部份的接口，目前都支持两种写法，分别是Promise 和 Async/Await，本节以 callFunction作为例子，在 云函数 中介绍这两种写法。 Async/Awai t 本质上是基于 Promise 的一种语法糖，它只是把 Promise 转换成同步的写法而已。Promiseconst app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\nexports.main = (event, context, callback) => {\r\n    app.callFunction({\r\n        name: 'addblog', // 云函数名称\r\n        data: { // 传到云函数处理的参数\r\n            title: '云开发 TCB',\r\n            content: '存储、数据库存、云函数'\r\n        }\r\n    }).then((res) => {\r\n        console.log(res);\r\n        callback(null, res.data);\r\n    }).catch((err) => {\r\n        callback(err);\r\n    });\r\n};Async/Awaitconst app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\nexports.main = async (event, context) => {\r\n    let result = null;\r\n\r\n    try {\r\n        result = await app.callFunction({\r\n            name: 'addblog', // 云函数名称\r\n            data: { // 传到云函数处理的参数\r\n                title: '云开发 TCB',\r\n                content: '存储、数据库存、云函数'\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        return e;\r\n    }\r\n\r\n    return result;\r\n};在云函数里使用，由于是 Node 8.9 或以上的环境，因此天然支持 Async/Await 诘法，但在小程端要使用的话，需要额外引入 Polyfill ，比如这个开源的项目： regenerator开发者资源由于小程序·云开发是基于腾讯云的云开发开发的功能，因此在腾讯云与小程序两边都有不少的开发者资源，这里供大家参阅读：腾讯云开发者资源及文档腾讯云云开发平台官方 Github微信小程序·云开发文档"}
{"title": "微信小程序之物流状态时间轴 ", "author": "Rolan", "pub_time": "2018-11-1 00:16", "content": "一个月左右没更新博客了，最近有点懒了哈（工作上真的忙），很多工作上学习到的东西都没有及时分享出来，有点愧疚，不过自己最近一直在收集资料和学习一些新技术，最主要是想要构建自己的前端技术体系和自定义一个前端规范文档，哈哈哈。说重点啦，微信小程序里面开发的商城模块还挺多的，刚好写了一个物流状态的时间轴，简单分享一下哈。（一）实现效果真机测试的结果（图片忘记缩小了）（二）实现分析页面布局拆分：简单的说：就是父级容器下，左边的子级容器是设置绝对定位（记得父级要设置相对定位哈），然后自己调位置，中间子级容器下放三个子容器（设置时间轴线、点的样式），右边的子级容器设置； wxml代码有备注信息 。（三）实现代码1、wxml代码：<view class='g_con'>\r\n\r\n  <view class='topExpress'>\r\n\r\n    <view class='topExpress-left'>\r\n      <image src='/images/Exchange_goods_map_1.png' style='width:60rpx;height:60rpx;border-radius:50%;'></image>\r\n    </view>\r\n    <view class='topExpress-right'>\r\n      <view class='topExpress-right-top'>圆通速递</view>\r\n      <view class='topExpress-right-middle'>运单号：813291235464788594</view>\r\n      <view class='topExpress-right-bottom'>官方电话 95554 ></view>\r\n    </view>\r\n\r\n  </view>\r\n\r\n  <!-- 物流时间轴 -->\r\n  <view class='expressRecord'>\r\n\r\n\r\n    <!-- 顶部收货地址 -->\r\n    <view class='expressRecord-getAddress'>\r\n      <view class='expressRecord-top'>\r\n        <view class='getAddress-icon'>\r\n          收\r\n        </view>\r\n        <view class='getAddress-text'>[收货地址] 广东省深圳市南山区 南山街道 亿利达大厦</view>\r\n      </view>\r\n    </view>\r\n\r\n    <!-- 顶部收货地址半个时间轴线 -->\r\n    <view class='noReach-online-top-close'></view>\r\n\r\n\r\n    <!-- 单个物流记录点时间轴：当前正在进行的物流状态 -->\r\n    <view class='expressRecord-single-close'>\r\n\r\n      <!-- 左边子容器 -->\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <!-- 正在进行的时间轴上半个时间线 -->\r\n        <view class='online-top-closing'></view>\r\n        <!-- 正在进行的时间轴点 -->\r\n        <view class='dot-closing'></view>\r\n        <!-- 正在进行的时间轴下半个时间线 -->\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <!-- 右边子容器 -->\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-statusing'>运输中</view>\r\n        <view class='expressRecord-status-addressing'>武汉转运中心公司 已发出，下一站 深圳转运中心</view>\r\n      </view>\r\n\r\n      <!-- 相对父级容器绝对定位的日期 -->\r\n      <view class='expressRecord-dating'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          20:39\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n    <!-- 单个物流记录点时间轴：已经过去的物流状态 -->\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'></view>\r\n        <view class='expressRecord-status-address'>武汉转运中心公司 已收入</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          20:37\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'></view>\r\n        <view class='expressRecord-status-address'>湖北省孝感市汉川市公司 已打包</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          14:37\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'>已揽件</view>\r\n        <view class='expressRecord-status-address'>湖北省孝感市汉川市公司 已收件</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          14:17\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <!-- 起始位置，下半个时间轴线不用 -->\r\n        <view class='online-bottom-start'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'>已发货</view>\r\n        <view class='expressRecord-status-address'>卖家发货</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          13:50\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  </view>\r\n\r\n\r\n\r\n</view>\r\n复制代码2、wxss代码：page {\r\n  background: #f4f4f4;\r\n}\r\n\r\n.g_con {\r\n  width: 100vw;\r\n  overflow-x: hidden;\r\n}\r\n\r\n.topExpress {\r\n  width: 710rpx;\r\n  height: 155rpx;\r\n  background: #fff;\r\n  margin: 10rpx auto;\r\n  display: flex;\r\n  border-radius: 10rpx;\r\n}\r\n\r\n.topExpress-left {\r\n  width: 100rpx;\r\n  height: 100%;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n.topExpress-right {\r\n  font-size: 26rpx;\r\n  color: #333;\r\n  display: flex;\r\n  justify-content: space-around;\r\n  flex-direction: column;\r\n  align-items: flex-start;\r\n  padding: 20rpx 0;\r\n}\r\n\r\n.topExpress-right-middle {\r\n  font-size: 22rpx;\r\n}\r\n\r\n.topExpress-right-bottom {\r\n  font-size: 20rpx;\r\n  color: #666;\r\n}\r\n\r\n.expressRecord {\r\n  width: 710rpx;\r\n  padding-top: 30rpx;\r\n  padding-bottom: 200rpx;\r\n  background: #fff;\r\n  margin: 0 auto;\r\n  border-radius: 10rpx;\r\n}\r\n\r\n.expressRecord-getAddress {\r\n  width: 100%;\r\n  font-size: 22rpx;\r\n  color: #999;\r\n  display: flex;\r\n}\r\n\r\n.expressRecord-top {\r\n  width: 100%;\r\n  display: flex;\r\n  justify-content: flex-start;\r\n  align-items: center;\r\n}\r\n\r\n.getAddress-icon {\r\n  width: 30rpx;\r\n  height: 30rpx;\r\n  border-radius: 50%;\r\n  background: #999;\r\n  font-size: 18rpx;\r\n  color: #fff;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  margin-left: 80rpx;\r\n}\r\n\r\n.getAddress-text {\r\n  margin-left: 20rpx;\r\n}\r\n\r\n.noReach-online-top-close {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #d7d7d7;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.expressRecord-single-close {\r\n  width: 100%;\r\n  height: 122rpx;\r\n  display: flex;\r\n  justify-content: flex-start;\r\n  align-items: center;\r\n  position: relative;\r\n}\r\n\r\n.expressRecord-single-noReach-online-top-close {\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.online-top-closing {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #d7d7d7;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.online-top-close {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #999;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.dot-closing {\r\n  width: 10rpx;\r\n  height: 10rpx;\r\n  border-radius: 50%;\r\n  margin-left: 90rpx;\r\n  margin-top: 6rpx;\r\n  margin-bottom: 6rpx;\r\n  background: #fe4f33;\r\n}\r\n\r\n.dot-close {\r\n  width: 10rpx;\r\n  height: 10rpx;\r\n  border-radius: 50%;\r\n  margin-left: 90rpx;\r\n  margin-top: 6rpx;\r\n  margin-bottom: 6rpx;\r\n  background: #999;\r\n}\r\n\r\n.online-bottom {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #999;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.online-bottom-start {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  /* background: #999; */\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.expressRecord-text {\r\n  margin-left: 30rpx;\r\n}\r\n\r\n.expressRecord-statusing {\r\n  font-size: 26rpx;\r\n  color: #333;\r\n}\r\n\r\n.expressRecord-status-addressing {\r\n  font-size: 22rpx;\r\n  color: #333;\r\n}\r\n\r\n\r\n.expressRecord-status {\r\n  font-size: 26rpx;\r\n  color: #999;\r\n}\r\n\r\n.expressRecord-status-address {\r\n  font-size: 22rpx;\r\n  color: #999;\r\n}\r\n\r\n.expressRecord-dating {\r\n  position: absolute;\r\n  height: 100%;\r\n  /* top: 0;\r\n  bottom: 0; */\r\n  left: 20rpx;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  flex-direction: column;\r\n  color: #333;\r\n}\r\n\r\n.expressRecord-date {\r\n  position: absolute;\r\n  height: 100%;\r\n  /* top: 0;\r\n  bottom: 0; */\r\n  left: 20rpx;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  flex-direction: column;\r\n  color: #999;\r\n}\r\n\r\n.expressRecord-date-text {\r\n  font-size: 24rpx;\r\n}\r\n\r\n.expressRecord-date-time {\r\n  font-size: 18rpx;\r\n}\r\n\r\n复制代码如果感觉有用的话，点个赞呗，支持一下我哈。"}
{"title": "各种小程序的组件机制差异 ", "author": "Rolan", "pub_time": "2018-10-18 00:12", "content": "在蚂蚁金服的开放平台上看到一些贴子，说提供一个工具，一键转换微信小程序为支付宝小程序。我与百度的人交流时，也听到相似的东西。其实都没有这么简单，它们最多是将一些循环条件分支指令改一下名，将一些文件的后缀名改一下，更多的差异点在API与各式的配置对象上，细节是魔鬼，我在娜娜奇的官网也列举了许多相关的东西，但也不能打票说已经很齐全。。。。各种小程序的差异点-文档补充一句，娜娜奇是我们公司的小程序开发框架，以React方式转译成各种小程序与快应用的框架。类似于京东的taro。最近忙于支付宝小程序的开发，我得到许多有关小程序的一手资料，包括自己测试得到的，及从百度，小米快应用与支付宝内部人士提供的。本文将重点说一下小程序的组件机制，之前娜娜奇的组件机制是基于template标签实现的，但百度的template有点BUG，给他们提了，不知现在修了没有。与template机制在快应用又出入太大，于是转向用自定义组件机制开发娜娜奇的组件机制。下面链接有一些相关的测试与说明转换小程序 · Issue #133 · RubyLouvre/anu经测试，使用了自定义组件机制的确是比template实现的简洁一些。但自定义组件机制是一个比较高级的特性，因此兼容性上比template差多了。只能内部推到各方改进了。微信在Component的配置对象提供了一些对象如methods， lifetimes，pageLifetimes，来减少其直辖的配置项。比如说lifetimes收纳了created、attached、ready、moved、detached这些生命周期钩子，pageLifetimes收纳了onShow, onHide这些与页面切换的钩子，methods收纳剩下的方法，另外还有许多配置项。的确，微信小程序独自发布这么久，肯定是最完善的支付宝的自定义组件机制没有properties，只有props，并且作用也不一样，props只是指定默认值，不是规定参数类型。支付宝也没有lifetimes与pageLifetimes对象，生命周期函数的名字也不一样 didMount 、didUpdate 、didUnmount，数量也少了，但从名称来看，支付宝在内部应该运行一个自己的迷你React。其他方面，支付宝没有 dataset， selectComponent，selectAllComponents，getRelationNodes这些东西，但支持了早被React废弃的mixin机制。支付宝没有created这样的钩子是相当麻烦的事，因此积级推动他们加上这个钩子！百度的自定义组件机制与微信的较为相近，但也没有lifetimes与pageLifetimes对象，只有4种生命周期钩子：created，attached，ready，detached。有selectComponent，selectAllComponents。快应用的页面与组件的配置对象都是一样，但它没有构造函数，只是要求我们export一个对象有props对象，用来定义类型与默认值，也有与state相似的data对象，也有三个做了访问限制的private, protected, public对象。生命周期钩子上有onInit、onReady、onDestroy这三个。从组件的设计来看， 微信 > 百度 > 支付宝 > 快应用因此想兼容这么多种小程序，我们必须自己写一个工厂方法，根据不同的平台生成不同的配置项，并且放弃掉一些微信的强大功能了。var hooksName = {\r\n\twx: ['created', 'attached', 'detached'],\r\n\tbu: ['created', 'attached', 'detached'],\r\n\tali: ['didMount', 'didMount', 'didUnmount'],\r\n\tquick: ['onInit', 'onReady', 'onDestroy'],\r\n};\r\n\r\nexport function registerComponent(type, name) {\r\n\tregisterComponents[name] = type;\r\n\tvar reactInstances = (type.reactInstances = []);\r\n\tvar wxInstances = (type.wxInstances = []);\r\n\tvar hooks = [\r\n\t\tfunction created() {\r\n\t\t\tvar instance = reactInstances.shift();\r\n\t\t\tif (instance) {\r\n\t\t\t\tconsole.log('created时为', name, '添加wx');\r\n\t\t\t\tinstance.wx = this;\r\n\t\t\t\tthis.reactInstance = instance;\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log('created时为', name, '没有对应react实例');\r\n\t\t\t\twxInstances.push(this);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfunction attached() {\r\n                        if(appType == \"ali\"){\r\n                            created.call(this)\r\n                        }\r\n\t\t\tif (this.reactInstance) {\r\n\t\t\t\tupdateMiniApp(this.reactInstance);\r\n\t\t\t\tconsole.log('attached时更新', name);\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log('attached时无法更新', name);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfunction detached() {\r\n\t\t\tthis.reactInstance = null;\r\n\t\t},\r\n\t];\r\n\tvar data = {\r\n\t\tprops: {},\r\n\t\tstate: {},\r\n\t\tcontext: {},\r\n\t};\r\n\tvar config = {\r\n\t\tdata: data,\r\n\t\tpublic: data,\r\n\t\tdispatchEvent: eventSystem.dispatchEvent,\r\n\t\tmethods: {\r\n\t\t\tdispatchEvent: eventSystem.dispatchEvent,\r\n\t\t},\r\n\t};\r\n\thooksName[appType].forEach(function(name, index) {\r\n\t\tconfig[name] = hooks[index];\r\n\t});\r\n\r\n\treturn config;\r\n}"}
{"title": "当微信小程序遇上 TensorFlow：接收 base64 编码图像数据 ", "author": "Rolan", "pub_time": "2018-10-18 00:21", "content": "这是 当微信小程序遇上TensorFlow 系列文章的第四篇文章，阅读本文，你将了解到：如何查看tensorflow SavedModel的签名如何加载tensorflow SavedModel如何修改现有的TensorFlow模型，增加输入层如果你想要了解更多关于本项目，可以参考这个系列的前三篇文章：当微信小程序遇上TensorFlow：Server端实现当微信小程序遇上TensorFlow：Server端实现补充当微信小程序遇上TensorFlow：小程序实现关于Tensorflow SavedModel格式模型的处理，可以参考前面的文章：Tensorflow SavedModel模型的保存与加载如何查看tensorflow SavedModel格式模型的信息如何合并两个TensorFlow模型问题截至到目前为止，我们实现了一个简单的微信小程序，使用开源的Simple TensorFlow Serving部署了服务端。但这种实现方案还存在一个重大问题：小程序和服务端通信传递的图像数据是(299, 299, 3)二进制数组的JSON化表示，这种二进制数据JSON化的最大缺点是数据量太大，一个简单的299 x 299的图像，这样表示大约有3 ～ 4 M。其实HTTP传输二进制数据常用的方案是对二进制数据进行base64编码，经过base64编码，虽然数据量比二进制也会大一些，但相比JSON化的表示，还是小很多。所以现在的问题是，如何让服务器端接收base64编码的图像数据？查看模型的签名为了解决这一问题，我们还是先看看模型的输入输出，看看其签名是怎样的？这里的签名，并非是为了保证模型不被修改的那种电子签名。我的理解是类似于编程语言中模块的输入输出信息，比如函数名，输入参数类型，输出参数类型等等。借助于Tensorflow提供的saved_model_cli.py工具，我们可以清楚的查看模型的签名：python ./tensorflow/python/tools/saved_model_cli.py show --dir /data/ai/workspace/aiexamples/AIDog/serving/models/inception_v3/ --all\r\n\r\nMetaGraphDef with tag-set: 'serve' contains the following SignatureDefs:\r\n\r\nsignature_def['serving_default']:\r\n  The given SavedModel SignatureDef contains the following input(s):\r\n    inputs['image'] tensor_info:\r\n        dtype: DT_FLOAT\r\n        shape: (-1, 299, 299, 3)\r\n        name: Placeholder:0\r\n  The given SavedModel SignatureDef contains the following output(s):\r\n    outputs['prediction'] tensor_info:\r\n        dtype: DT_FLOAT\r\n        shape: (-1, 120)\r\n        name: final_result:0\r\n  Method name is: tensorflow/serving/predict从中我们可以看出模型的输入参数名为image，其shape为(-1, 299, 299, 3)，这里-1代表可以批量输入，通常我们只输入一张图像，所以这个维度通常是1。输出参数名为prediction，其shape为(-1, 120)，-1和输入是对应的，120代表120组狗类别的概率。现在的问题是，我们能否在模型的输入前面增加一层，进行base64及解码处理呢？也许你认为可以在服务器端编写一段代码，进行base64字符串解码，然后再转交给Simple Tensorflow Serving进行处理，或者修改Simple TensorFlow Serving的处理逻辑，但这种修改方案增加了服务器端的工作量，使得服务器部署方案不再通用，放弃！修改模型，增加输入层其实在上一篇文章《 如何合并两个TensorFlow模型 》中我们已经讲到了如何连接两个模型，这里再稍微重复一下，首先是编写一个base64解码、png解码、图像缩放的模型： base64_str = tf.placeholder(tf.string, name='input_string')\r\n  input_str = tf.decode_base64(base64_str)\r\n  decoded_image = tf.image.decode_png(input_str, channels=input_depth)\r\n  # Convert from full range of uint8 to range [0,1] of float32.\r\n  decoded_image_as_float = tf.image.convert_image_dtype(decoded_image,\r\n                                                        tf.float32)\r\n  decoded_image_4d = tf.expand_dims(decoded_image_as_float, 0)\r\n  resize_shape = tf.stack([input_height, input_width])\r\n  resize_shape_as_int = tf.cast(resize_shape, dtype=tf.int32)\r\n  resized_image = tf.image.resize_bilinear(decoded_image_4d,\r\n                                           resize_shape_as_int)\r\n  tf.identity(resized_image, name=\"DecodePNGOutput\")接下来加载retrain模型： with tf.Graph().as_default() as g2:\r\n    with tf.Session(graph=g2) as sess:\r\n      input_graph_def = saved_model_utils.get_meta_graph_def(\r\n          FLAGS.origin_model_dir, tag_constants.SERVING).graph_def\r\n\r\n      tf.saved_model.loader.load(sess, [tag_constants.SERVING], FLAGS.origin_model_dir)\r\n\r\n      g2def = graph_util.convert_variables_to_constants(\r\n          sess,\r\n          input_graph_def,\r\n          [\"final_result\"],\r\n          variable_names_whitelist=None,\r\n          variable_names_blacklist=None)这里调用了graph_util.convert_variables_to_constants将模型中的变量转化为常量，也就是所谓的冻结图(freeze graph)操作。利用tf.import_graph_def方法，我们可以导入图到现有图中，注意第二个import_graph_def，其input是第一个graph_def的输出，通过这样的操作，就将两个计算图连接起来，最后保存起来。代码如下： with tf.Graph().as_default() as g_combined:\r\n    with tf.Session(graph=g_combined) as sess:\r\n      x = tf.placeholder(tf.string, name=\"base64_string\")\r\n      y, = tf.import_graph_def(g1def, input_map={\"input_string:0\": x}, return_elements=[\"DecodePNGOutput:0\"])\r\n      z, = tf.import_graph_def(g2def, input_map={\"Placeholder:0\": y}, return_elements=[\"final_result:0\"])\r\n\r\n      tf.identity(z, \"myOutput\")\r\n\r\n      tf.saved_model.simple_save(sess,\r\n                                 FLAGS.model_dir,\r\n                                 inputs={\"image\": x},\r\n                                 outputs={\"prediction\": z})如果你不知道retrain出来的模型的input节点是啥（注意不能使用模型部署的signature信息）？可以使用如下代码遍历graph的节点名称：for n in g2def.node:\r\n  print(n.name)模型部署及测试注意，我们可以将连接之后的模型保存在./models/inception_v3/2/目录下，原来的./models/inception_v3/1/也不用删除，这样两个版本的模型可以同时提供服务，方便从V1模型平滑过渡到V2版本模型。我们修改一下原来的test_client.py代码，增加一个model_version参数，这样就可以决定与哪个版本的模型进行通信： with open(file_name, \"rb\") as image_file:\r\n    encoded_string = str(base64.urlsafe_b64encode(image_file.read()), \"utf-8\")\r\n\r\n  if enable_ssl :\r\n    endpoint = \"https://127.0.0.1:8500\"\r\n  else:\r\n    endpoint = \"http://127.0.0.1:8500\"\r\n\r\n  json_data = {\"model_name\": model_name,\r\n               \"model_version\": model_version,\r\n               \"data\": {\"image\": encoded_string}\r\n              }\r\n  result = requests.post(endpoint, json=json_data)小结经过一个多星期的研究和反复尝试，终于解决了图像数据的base64编码通信问题。难点在于虽然模型是编写retrain脚本重新训练的，但这段代码不是那么好懂，想要在retrain时增加输入层也是尝试失败。最后从Tensorflow模型转Tensorflow Lite模型时的freezing graph得到灵感，将图中的变量固化为常量，才解决了合并模型变量加载的问题。虽然网上提供了一些恢复变量的方法，但实际用起来并不管用，可能是Tensorflow发展太快，以前的一些方法已经过时了。本文的完整代码请参阅：https://github.com/mogoweb/aiexamples/tree/master/AIDog/serving点击 阅读原文 可以直达在github上的项目。到目前为止，关键的问题已经都解决，接下来就需要继续完善微信小程序的展现，以及如何提供识别率，敬请关注我的微信公众号：云水木石，获取最新动态。参考How to Show Signatures of Tensorflow Saved ModelServing Image-Based Deep Learning Models with TensorFlow-Serving’s RESTful APITensorflow: How to replace a node in a calculation graph?"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "微信小程序兼容性问题 ", "author": "Rolan", "pub_time": "2018-8-16 00:23", "content": "在微信小程序开发中，经常会遇到一些兼容性的问题，我最近就遇到了一个问题，就是在时间字符串转化为时间戳的方法中，我用的Date.parse(new Date())这个方法，但是在微信开发者工具中这个方法正常实现，但是在一些iphone设备和安卓的部分设备中不会实现相关功能，为了解决这个问题我只能导入了momentjs，不在调用系统方法了。这里我们就来讨论一下一些兼容性问题。运行环境差异微信小程序运行在三端：iOS、Android 和 用于调试的开发者工具。三端的脚本执行环境以及用于渲染非原生组件的环境是各不相同的：在 iOS 上，小程序的 javascript 代码是运行在 JavaScriptCore 中，是由 WKWebView 来渲染的，环境有 iOS8以上 在 Android 上，小程序的 javascript 代码是通过 X5 JSCore来解析，是由 X5 基于 Mobile Chrome 53/57 内核来渲染的 在 开发工具上， 小程序的 javascript 代码是运行在 nwjs 中，是由 Chrome Webview 来渲染的 尽管三端的环境是十分相似的，但是还是有些许区别：ES6 语法支持不一致 语法上开发者可以通过开启 ES6 转 ES5 的功能来规避。wxss 渲染表现不一致 尽管可以通过开启样式补全来规避大部分的问题，还是建议开发者需要在 iOS 和 Android 上分别检查小程序的真实表现。ES6 转 ES5在 0.10.101000 以及之后版本的开发工具中，会默认使用 babel 将开发者 ES6 语法代码转换为三端都能很好支持的 ES5 的代码，帮助开发者解决环境不同所带来的开发问题。 样式补全开启此选项，开发工具会自动检测并补全缺失样式，保证在低版本系统上的正常显示。尽管可以规避大部分的问题 ，还是建议开发者需要在 iOS 和 Android 上分别检查小程序的真实表现。样式补全兼容小程序的功能不断的增加，但是旧版本的微信客户端并不支持新功能，所以在使用这些新能力的时候需要做兼容。文档会在组件，API等页面描述中带上各个功能所支持的版本号。可以通过 wx.getSystemInfo 或者 wx.getSystemInfoSync 获取到小程序的基础库版本号。可以通过 wx.canIUse 来判断是否可以在该基础库版本下直接使用对应的API或者组件获取系统信息同步let res = wx.getSystemInfoSync() console.log(\"同步获取系统信息：\" + res);  console.log(res);异步：wx.getSystemInfo({      success: function(res) {        console.log(\"异步获取系统信息:\");        console.log(res);      },    })版本比较微信客户端和小程序基础库的版本号风格为 Major.Minor.Patch（主版本号.次版本号.修订号）。 开发者可以根据版本号去做兼容function compareVersion(v1, v2) {  v1 = v1.split('.')  v2 = v2.split('.')  var len = Math.max(v1.length, v2.length)  while (v1.length < len) {    v1.push('0')  }  while (v2.length < len) {    v2.push('0')  }  for (var i = 0; i < len; i++) {    var num1 = parseInt(v1[i])    var num2 = parseInt(v2[i])    if (num1 > num2) {      return 1    } else if (num1 < num2) {      return -1    }  }  return 0}compareVersion('1.11.0', '1.9.9')// 1该基础库版本下直接使用对应的API或者组件的APIwx.canIUse(String)判断小程序的API，回调，参数，组件等是否在当前版本可用。此接口从基础库 1.1.1 版本开始支持。String参数说明： 使用{API}.{method}.{param}.{options}或者{component}.{attribute}.{option}方式来调用，例如：{API} 代表 API 名字 {method} 代表调用方式，有效值为return, success, object, callback {param} 代表参数或者返回值 {options} 代表参数的可选值 {component} 代表组件名字 {attribute} 代表组件属性 {option} 代表组件属性的可选值例子：wx.canIUse('openBluetoothAdapter')wx.canIUse('getSystemInfoSync.return.screenWidth')wx.canIUse('getSystemInfo.success.screenWidth')wx.canIUse('showToast.object.image')wx.canIUse('onCompassChange.callback.direction')wx.canIUse('request.object.method.GET')wx.canIUse('live-player')wx.canIUse('text.selectable')wx.canIUse('button.open-type.contact')Javascript 标准库兼容性问题微信小程序的兼容性问题除了微信本身的 Bug 外，大部分是目标平台对 JavaScript 标准库支持程度不同造成的。像我最上面遇到的问题就是Javascript 标准库兼容性问题。对于这类问题我们可以打补丁，从其他地方找到比较完善的js代码，然后我们拷贝到我们的项目中。作者：辉哥de简书 链接：https://www.jianshu.com/p/0eabd560b5a8"}
{"title": "使用mpvue开发github小程序总结 ", "author": "Rolan", "pub_time": "2018-8-22 00:37", "content": "最近有点闲，想起关注已久的 mpvue 写小程序，所以稍微肝了半个多月写了个 github 版的微信小程序，已上线。现在总结一下遇到的坑。项目地址、 github.com/cheesekun/w…mina坑scroll-view 高度可滚动视图区域。使用竖向滚动时，需要给 <scroll-view/> 一个固定高度，通过 WXSS 设置 height。小程序提供的 scroll-view 组件，想让他能滚动，就要给他提供一个固定的高度。我们一般需求是，上一块区域固定，下一块区域可滚动，我的处理方法是，拿到机型的可视高度，减去上一块固定区域的高度，动态赋值 scroll-view 最终高度。// 以 search 页为例\r\n// 滚动区域高度 = 总高度 - 搜索框高度 - tabs 高度\r\nonLoad () {\r\n  wx.getSystemInfo({\r\n    success: (res) => {\r\n      this.height = res.windowHeight // 获取机型可视高度\r\n    }\r\n  })\r\n\r\n  let query = wx.createSelectorQuery()\r\n  // 选择id\r\n  query.select('#search').boundingClientRect()\r\n\r\n  query.exec(res => {\r\n    let searchH = res[0].height // 获取search框高度\r\n    this.height = this.height - searchH - this.tabsH\r\n  })\r\n}\r\n复制代码坑点： wx.createSelectorQuery() 获取不了 display: none 的元素高度。我的解决方法是：在 trending 页获取到 tabs 组件的高度，再存放到 vuex 中，给 search页使用生命周期（同一page携带不同参数）小程序生命周期当我们从一个页面①进入页面②时，我们一般在 onLoad 进行初始数据的获取，从页面②返回到页面①时，若两个页面是不同的page，如 ①为page/info ，②为page/repo，那没问题，①页面 unOnLoad ，②页面 onShow 。但是若 ①为page/info?user=a ， ②为page/info?user=b ，那gg了，从页面②返回到页面①，页面①的数据会变成页面②的数据为了避免这种情况，我一开始使用 onShow 代替 onLoad ，也就是在 onShow 的时候获取页面的初始数据。但是这个情况就有点可怕了，我们知道 onShow 很多情况都会触发到，切换前后台，从一个页面返回到另一个，都会触发 onShow ，这就导致会触发很多不必要的请求，而且用户体验极差。可我很多需求就是类似从 ①为page/info?user=a 到 ②为page/info?user=b ，因此曲线救国想出用 vuex 维护有相关需求页面的路由栈。页面 onLoad 的时候，推入query参数到栈中， onShow 时，若当前页面的参数和栈中最后一个元素相同，则不重新加载数据。当页面被销毁，则在 onUnload 中把相应的页面栈推出。这样就可以避免很多无谓的 onShow 请求。onLoad () {\r\n    this.reset()\r\n    const options = getQuery()\r\n    user = options.login\r\n    // vuex\r\n    this.reposStack.push(options)\r\n\r\n    this.getRepos()\r\n  },\r\n  onShow () {\r\n    const options = getQuery()\r\n    // vuex\r\n    let reposStack = JSON.parse(JSON.stringify(this.reposStack))\r\n    let len = reposStack.length\r\n    let endStack = reposStack[len - 1]\r\n    if (JSON.stringify(endStack) === JSON.stringify(options)) {\r\n      return\r\n    }\r\n    this.reset()\r\n    user = options.login\r\n    this.getRepos()\r\n  },\r\n  onUnload () {\r\n    // vuex\r\n    this.reposStack.slice(0, -1)\r\n  }\r\n复制代码mpvue坑query参数mpvue 可以通过  this.$root.$mp.query 在所有页面的组件内获取路径参数。如果以 mina 来说的话，我们是通过在生命周期 onLoad(options) ，拿到 options 上携带的路径参数， mpvue 提供了 this.$root.$mp.query ,我们可以所有生命周期上使用。但是我们知道，当我们从当前页返回到上一页时，上一页并不会执行 onLoad() ,假设当前页和上一页是同个 page ，只是携带参数不同的话，此时回退到上一页，上一页的 this.$root.$mp.query 不会变成自己的 query ，还是会变成当前页的 query举例：①page/info?a=1 => ②page/info?b=2当我从②返回到①时，①的 this.$root.$mp.query 会变成 {b:2}我猜 mpvue 的 this.$root.$mp.query 是通过 onLoad(options) 获取到 options ，再赋值。但是遇到小程序页面返回不会执行 onLoad为了避免麻烦，我直接使用了小程序的api getCurrentPages() ，获取路由栈中最后一个路由的参数getCurrentPages() 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。/**\r\n * 获取当前路径参数\r\n * 不用mpvue提供的this.$root.$mp.query\r\n * 因为其进入同一页面，参数不会变化\r\n*/\r\nexport function getQuery () {\r\n  /* 获取当前路由栈数组 */\r\n  const pages = getCurrentPages()\r\n  const currentPage = pages[pages.length - 1]\r\n  const options = currentPage.options\r\n\r\n  return options\r\n} \r\n复制代码后记前面几个问题是我初次使用 mpvue 开发小程序遇到的最大的坑了吧。（好久没有写东西了，写得好烂。）不过确实使用 mpvue 开发小程序，能组件化，支持 npm ，比原生开发舒服很多。体验还是很好的。 小程序现在是真的太火了。感觉是个前端都要去玩一下。 再次推一下项目地址，有兴趣的朋友可以参考一下。 github.com/cheesekun/w…作者：芝士君原文：https://juejin.im/post/5b7bd9ea51882542d23a0e3d"}
{"title": "微信小程序实现类3D轮播图 ", "author": "Rolan", "pub_time": "2018-8-30 00:21", "content": "效果图如下：1.swiper的相关属性indicator-dots 是否显示小圆点，也可以自己重新设置小圆点circular 是否衔接滑动，就是实现无限滚动previous-margin 与上一张图片的间距next-margin 与下一张图片的间距autoplay 实现自动滚动这里主要利用了circular实现无限滚动，然后再加上前后间距，再设置图片的层级和透明度就可以实现了,将图片及容器的高度设置好就差不多可以实现了wxml文件<!--carousel/index.wxml-->\r\n<swiper class=\"imageContainer\" bindchange=\"handleChange\" previous-margin=\"50rpx\" next-margin=\"50rpx\" circular autoplay>\r\n  <block wx:for=\"{{3}}\" wx:key=\"{{index}}\">\r\n    <swiper-item class=\"item\">\r\n      <image class=\"itemImg {{currentIndex == index ? 'active': ''}}\" src=\"../../../image/3.jpg\"></image>\r\n    </swiper-item>\r\n  </block>\r\n</swiper>wxss文件/* carousel/index.wxss */\r\npage{\r\n  background: #f7f7f7f7;\r\n}\r\n.imageContainer{\r\n  width: 100%;\r\n  height: 500rpx;\r\n  background: #000;\r\n}\r\n.item{\r\n  height: 500rpx;\r\n}\r\n.itemImg{\r\n  position: absolute;\r\n  width: 100%;\r\n  height: 380rpx;\r\n  border-radius: 15rpx;\r\n  z-index: 5;\r\n  opacity: 0.7;\r\n  top: 13%;\r\n}\r\n.active{\r\n  opacity: 1;\r\n  z-index: 10;\r\n  height: 430rpx;\r\n  top: 7%;\r\n  transition:all .2s ease-in 0s;\r\n}JS文件// carousel/index.js\r\nPage({\r\n\r\n  data: {\r\n    currentIndex: 0\r\n  },\r\n\r\n  onLoad: function (options) {\r\n  \r\n  },\r\n  /* 这里实现控制中间凸显图片的样式 */\r\n  handleChange: function(e) {\r\n    this.setData({\r\n      currentIndex: e.detail.current\r\n    })\r\n  },\r\n})正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：画三角形webpack打包（有面试题）setInterval与setTimeout"}
{"title": "实现一个扫描商品条码进行评价或留言的小程序（附源码） ", "author": "Rolan", "pub_time": "2018-9-5 00:08", "content": "对准上面的小程序码，扫一下，‘嘀’~地一声，扫码成功，打开小程序，进入小程序首页。因为手头上没有可乐，所以我找来了一只非常专业的猫，扮演一瓶330ml的可口可乐演示给大家看。摁住它，对准它的条码，扫一下，‘喵’~地一声，说明猫跑掉了，扫码失败了，去追如果‘嘀’~地一声，说明扫码成功了，这时页面就自动跳到商品详情页。然后你就可以看得到别人在可口可乐下写的留言，当然你也可以点击右下角的蓝色按钮就发表你的留言了；原理：因为一个商品对应唯一一个条码，所以扫描同一个商品条码就可以进入唯一一个留言列表；全国各地的可口可乐330ml的条形码都是一样的，扫码后都会进入同一个页面条形码就像一个暗号，一句口令，一个邮差.. 当然，不只是条形码，二维码也可以留言，比如说别人的微信二维码一般是长时间不会变的，你可以码上说别人坏话。接下来详细介绍一下每个页面的功能2.首页首页有三个部分：1.用户的信息：头像和昵称；2.轮播图-可以放一些平时要展示的图片；3.扫码按钮-点击即可打开扫描条码；当用户点击扫码按钮时，我们就调用小程序的扫码接口去扫描商品条码，当用户扫描好条码后，我们就得到了商品条码（barcode）；这时，我们就可以跳转到商品详情页面了，顺便把条码传过去，这样商品详情页才能知道用户扫的是什么商品：wx.navigateTo({\r\n          url: \"/page/component/proDtl/proDtl?barcode=\" + barcode,  //把商品条码传给商品详情页\r\n    })\r\n复制代码3.商品详情页进入详情页后，我们的第一件事情：在生命周期onLoad中获取首页传过来商品条码，然后根据条码请求当前商品的留言列表，如果这个商品还没有人扫过的话，就可能没有留言，那我们只要显示“暂无留言”即可onLoad(options){\r\n       var barcode = options.barcode ? options.barcode:'';\r\n       this.getProductInfo(barcode)  //根据条码请求当前商品的留言列表\r\n  },\r\n复制代码在getProductInfo（）方法中，我们会向后台请求商品留言列表； 接着我们就把请求到的商品留言列表渲染到页面上:如果用户觉得请求到的商品名称是不对的，还可以点击名称进行编辑：最后，页面底部还有一个提交留言的小按钮：如果你要发表留言，你可以用你的食指点击它：点击按钮后，小程序就会跳到添加留言页面，顺便把商品条码信息传过去：turnToSubmit(){\r\n    wx.navigateTo({\r\n      url: \"/page/component/addNode/addNode?barcode=\" + this.data.barcode,\r\n    })\r\n  },\r\n复制代码4.添加留言页面如图，这时候我们就可以开始写我们的留言了。写完留言之后，你可以标注一下你的留言类型：如果你觉得你写的是一首诗，你可以选择类型为‘诗一首’；如果你觉得你写的是一封信，等待别人扫码阅读，你可以选择类型为‘鱼书’；如果你扫描的是一本书的条码，你可以选择类型为‘书摘’；类型的右边就是是上传图片功能，首先，我们点击'添加图片'小图标，这时就会使用小程序选择图片的接口打开相册或者直接拍照，得到图片之后，因为现在的手机图片拍照像素都比较高，导致图片比较大，上传会很慢，占服务器空间，请求也会很慢...所以为了优化用户体验，我们需要压缩一下图片然后再上传。wx.chooseImage({\r\n      count: 1, // 默认9  \r\n      sizeType: ['original'], // 可以指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success: function (res) {  //图片选择成功之后\r\n        \r\n               var tempFilePaths = res.tempFilePaths;\r\n               self.compressedImg(res)  //调用compressedImg方法，先把图片压缩一下\r\n\r\n        }\r\n  })\r\n复制代码虽然小程序的选择图片接口可以设置默认压缩，但好像没什么用，还是需要找其他的方法压缩一下， 网上最普遍的图片压缩是使用了小程序提供的canvas画布，把用户上传的图片搞到画布上（....），然后根据画布上的图片高和宽判断图片是否过大，如果过大，就直接把画布按比例缩小：while (canvasWidth > 220 || canvasHeight > 220) {  //如果宽度或者高度大于220，我就认为图片要进一步压缩，你可以根据需求改成其他的数字\r\n          //比例取整\r\n      canvasWidth = Math.trunc(res.width / ratio)\r\n      canvasHeight = Math.trunc(res.height / ratio)\r\n      ratio++;\r\n   }\r\n复制代码图片的压缩参考自：[微信小程序：利用canvas缩小图片][ blog.csdn.net/akony/artic… ]然后把canvas上这张压缩了的图片上传到后台服务器：......\r\n   wx.uploadFile({  //上传图片\r\n          url: 'https://mp.orancat.com/proImgUpload',\r\n          filePath: photo.tempFilePath,  //压缩后的图片\r\n          name: 'file',\r\n          header: {\r\n            'content-type': 'multipart/form-data'\r\n          },\r\n          success: function (res) {\r\n    .......          \r\n\r\n复制代码图片上传成功之后，后台会返回上传图片的地址给我们，我们把图片渲染到页面上，用户就会知道图片上传成功了；最后点击'提交'按钮，就会把以下内容发送给后台，后台就会自动将留言保存到数据库；var data={\r\n      authorName: userName, //用户昵称\r\n      token: userId,  //用户ID\r\n      content: this.data.textContent, //留言文本内容\r\n      imgUrl: userImg,  //用户的头像\r\n      code: this.data.barcode,  //商品的条码\r\n      typeIndex: this.data.typeIndex, //留言的类型\r\n      nodeImgUrl: this.data.nodeImgUrl //用户上传的图片的地址\r\n    }\r\n复制代码留言提交成功之后，页面会自动切回商品详情页面，这时，你就可以看到自己刚刚的留言了；5.排行榜页面有过留言的商品都会出现在排行榜页面，并且按照留言的数量多少进行排列，点击单个商品就查看该商品下的留言；6.其他实现的功能1.分页在商品详情页，有可能出现这种情况，比如说假设A商品有120条留言，如果一进A商品详情页就要加载120条留言的话，可能页面加载半天都没有出来；这样的话用户体验就会非常不好。所以相对理想的方式应该是，假设12条留言为一页，那么A商品的留言总共有10页，当我们进入A商品的详情页面时，先加载第一页（前12条留言），当我们往上滑动页面到底部时就自动加载下一页的内容，一页一页按需加载；我们使用小程序提供的OnReachBottom触底事件实现分页加载，当用户滑动留言列表到底部时触发加载下一页：onReachBottom: function () { //滑动到底部时触发\r\n       this.setData({\r\n           bottomLoading: true  // 显示loading提示\r\n       })\r\n       this.getRankList()  //请求下一页数据\r\n  }\r\n复制代码同理，排行榜页面也使用了分页加载；2.通过wx.login获取用户唯一凭证openId由于用户的昵称，头像什么的都可能随时会改变，当openID不会变，所以使用openId作为用户唯一凭证；虽然我获取了用户的Id，但暂时还没有使用到；如果以后要弄个用户个人主页或者留言回复等等可能就要用到openId；3.gif图片上传如上所述，在图片上传前，我们把图片压缩了一下 如果图片是jpeg，png时没问题的 但如果图片时gif动图的话，那可能会导致动图不会动了（可能直接变成jpeg图片？） 所以我另外加了一个判断：如果图片时gif格式的话，就不压缩图片,直接上传：if(res.type=='gif'){\r\n       if(res.width>666||res.height>666){ //如果图片太大了，拒绝上传\r\n         wx.hideLoading()\r\n         wx.showModal({\r\n           title: '提示',\r\n           content: '动图太大了，请上传小一点的',\r\n           showCancel: false\r\n         })\r\n         return false;\r\n       }\r\n       res.tempFilePath=res.path;\r\n       _this.uploadImg(res)  //上传图片\r\n       return false;\r\n    }\r\n复制代码这样在window和安卓下就可以上传gif图片了。苹果手机呢？？咳咳..苹果手机一打开相册选动图，动图就自动变成了jpeg的不动图...所以苹果手机暂时上传不了动图，似乎没有解决办法。。7.下载与本地电脑运行在本文底部的github地址下载源码，用微信开发者工具，填上你的小程序appId，打开项目即可；记得在开发者工具点击‘’详情‘’设置不校验域名：如果你要提交审核并分布小程序的话，你需要在公众号平台上的\"设置>开发设置\"页面上设置小程序的服务器域名如下：然后，由于一般电脑没有摄像头不能扫码，所以当你需要扫码时，你可以把下面这张条码图片保存在本地电脑上，点击扫码按钮时打开这张图片即可：当然，你也可以自己找其他的条码；另外，需要注意的是，当你在本地电脑调试时，由于我们都是使用同一个后台接口，所以你发的留言都会同步到我的小程序上，所以尽量不要发送太明显的测试留言，例如：可以发一些强颜欢笑，积极向上，人畜无害的留言，例如："}
{"title": "golang+json-iterator（微信小程序推送通知实例） ", "author": "Rolan", "pub_time": "2018-9-11 00:12", "content": "结构体如下：type WxPushContent struct {\r\n    Push_record_id   int    `json:\"push_record_id\"`\r\n    Template_id      string `json:\"template_id\"`\r\n    Page             string `json:\"page\"`\r\n    Data             Data   `json:\"data\"`\r\n    Emphasis_keyword string `json:\"emphasis_keyword\"`\r\n}\r\n\r\ntype Data struct {\r\n    Keyword1 WxKeyword `json:\"keyword1\"`\r\n    Keyword2 WxKeyword `json:\"keyword2\"`\r\n    Keyword3 WxKeyword `json:\"keyword3\"`\r\n}\r\n\r\ntype WxKeyword struct {\r\n    Value string `json:\"value\"`\r\n}实际代码如下：func ExecutePush_WX(ctx *gin.Context) {\r\n  var json_iterator = jsoniter.ConfigCompatibleWithStandardLibrary\r\n\r\n  jsonWxPushContent, _ := json_iterator.Marshal(models.WxPushContent{\r\n    Push_record_id:   note.Id,\r\n    Template_id:      setting.MINITemplateId,\r\n    Page:             \"/pages/detail?isShare=true&isFromPush=\" + strconv.Itoa(note.Id) + \"&id=\" + strconv.FormatInt(note.NewsId, 10),\r\n    Data:             models.Data{\r\n      Keyword1:models.WxKeyword{Value: \"热点新闻\"},\r\n      Keyword2:models.WxKeyword{Value: news.Title},\r\n      Keyword3:models.WxKeyword{Value: tt[0].Summary},\r\n    },\r\n    Emphasis_keyword: \"keyword1.DATA\"})\r\n  }\r\n\r\n  log.Println(\"小程序-加密前的参数: \", string(jsonWxPushContent))返回结果：{\r\n    \"push_record_id\":33,\r\n    \"template_id\":\"3OviTbpRI-7t8GJxlaoKtyQM6SuOXnROVk-jwj-T-GI\",\r\n    \"page\":\"/pages/detail?isShare=true&isFromPush=33&id=63688\",\r\n    \"data\":{\r\n        \"keyword1\":{\r\n            \"value\":\"热点新闻\"\r\n        },\r\n        \"keyword2\":{\r\n            \"value\":\"人工智能是否会颠覆传统电视行业？\"\r\n        },\r\n        \"keyword3\":{\r\n            \"value\":\"据了解，近日长虹再次与人工智能领先企业达观数据达成合作，将电视内容的个性化推荐引入智能电视，为用户更好的打造智慧家庭体系\"\r\n        }\r\n    }\r\n    \"emphasis_keyword\":\"keyword1.DATA\"\r\n}之后就是请求微信小程序api地址拉！"}
{"title": "玩Android微信小程序版 ", "author": "Rolan", "pub_time": "2018-9-17 00:12", "content": "最近开始针对项目性全面学习了一点js，和同事一起用MUI写了个项目，就敢拿出来献丑，我也是diaodiao的。经过几十个工时业余时间*（最近两周有点忙，周期拖得有点长，本来计划五一之前发出来的） ，在 仿知乎微信小程序demo 基础上，结合玩Android开源API，完成了玩Android小程序版的初版 （和群里基佬们做得比感觉做的太简单了，大家就当练练手）*，扫码或者关注微信公众号 Android精推 即可体验：本项目主要包含以下几大模块：首页项目体系我的登录先上预览图：首页：项目：体系：我的：为什么要写这个？学了点js就飘了，群里大佬们写的都是Android版本的，微信小程序大家似乎都有接触但是可能都觉得比较简单，也是为了便于手持iPhone的基佬们随时点赞刷玩Android。说几点：1. 微信小程序开发入门注意事项这里就不赘述太多，看我基友 阿汤哥 的一篇文章小程序基本介绍就差不多了。简单归简单，不过微信小程序在开发过程中坑还是很多的，我也是边学边百度，我这个人踩坑踩惯了，建议大家初学的时候，找个优质一点的demo照葫芦画瓢，学着写很容易上手。2. 未实现的功能首页文章列表搜索*（计划V1.1实现）*收藏列表*（计划V1.1实现）*查看文章详情等需要跳转h5页面的功能*（计划搞到企业账号实现）*收藏项目等*（目前已实现收藏文章）*剩下的你们提，我做不出来*（或者没时间）*你们fork去3. 微信小程序代码写法的一些特点工具类等输出对公共方法写方法体还是一样function formatNumber(n) {\r\n   n = n.toString()\r\n   return n[1] ? n : '0' + n\r\n}\r\n复制代码或者function getData(url) {\r\n     XXXXXX\r\n}\r\n复制代码都和我们原生js写法、jquery等几乎一致，然鹅要注意一点就是如果该方法需要外部调用，需要多加一个：module.exports = {\r\n   formatTime: formatTime\r\n};\r\n复制代码在文件里加上这个，或者也可以写成：module.exports.getData = getData;\r\n复制代码####js页面数据刷新html（wxml） 微信小程序绑定js数据不像angular那样，在每个页面的js文件中，都有个类似oncreat的方法，即Page() 函数，它是用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等这里每个页面的WXML 中的动态数据均来自对应 Page 的 data。给页面初始赋值可以在data里面直接放置：data: {\r\n      motto: 'Hello World',\r\n      userInfo: {},\r\n      wanUserName: '登录玩Android账户',\r\n   }\r\n复制代码而我们经过数据处理以后，需要实时更新页面则可以直接调用：//更新数据\r\n         that.setData({\r\n            userInfo: userInfo\r\n         })\r\n复制代码对，就是键值对的方式，和data一样。这里需要注意的是 that 这个，我们一般会在方法体内部先var一个参数that去获取全局实例 this ，这样避免方法自己的实例取代了页面的全局实例。this代表着当前对象，会随着程序的执行过程中的上下文改变，例如在wx.request({});方法的回调函数中，对象已经发生改变，所以已经不是wx.request({});方法对象了，data属性也不存在了。页面销毁与返回那么在微信小程序里我们怎么管理页面呢。微信小程序固然没有AMS这些东西，那么我们可以判断page来管理：// 返回上个页面\r\n         setTimeout(function () {\r\n            wx.navigateBack({\r\n               delta: 1\r\n            })\r\n         }, 1500);\r\n复制代码这里我设置了一个延迟，核心的代码是wx.navigateBack(),这里面的参数delta指的是退回页面的层数，比如我这里是返回上一页，那么值就是1，以此类推。。。但是我们一般返回上个页面的时候也会带一定的参数，这里就有三种*（可能更多） 介绍给大家： 1、利用本地存储 （类似Android的sp）*方式存储起来，这里去看看官方文档很简单，都是wx.XXX的。 2、利用生命周期传递，例如：var pages = getCurrentPages();\r\nvar currPage = pages[pages.length - 1];   //当前页面\r\nvar prevPage = pages[pages.length - 2];  //上一个页面\r\n//直接调用上一个页面的setData()方法，把数据存到上一个页面中去\r\nprevPage.setData({\r\n  mydata: {a:1, b:2}\r\n})\r\n复制代码这里是在简书的 微信小程序从子页面退回父页面时的数据传递 学习到的。这种方式在逻辑上要清晰得多，也不存在对数据的销毁有额外的管理工作，看起来十分优雅，从一定的角度说类似于Android的ActivityForResult方式。当然有利也是有弊的，比如使用这个页面的有多个入口，这样做很可能会导致获取到的页面实例不正确。当然如果对于逻辑层次简单的、耦合少的页面还是比较方便的。3、使用fire传递，这个方式是类似于我们EventBus的方式，后面有详解。利用第三方工具fire实现类似EventBus全局事件通知之前说到，fire是一个非常轻量级的第三方的组件库，在微信小程序限制项目大小2MB的情况下，在js调用中可以实现类似EventBus的全局事件订阅管理，非常简单好用。 1、首先，导fire文件，这个去网上下载一个*（不到1KB）*就可以，直接把onfire.js文件拷过来。 2、写订阅事件和接受者的时候：A 页面先订阅一个事件，并定义处理方法；从 B 页面返回时，发送消息；A 页面卸载时，解除订阅。是不是一毛一样的？不仅仅在微信小程序中，包括vue、React等都可以使用，具体使用*（无非是一行代码发送消息，接收消息的时候写一个方法）*可以去自行百度。列表单个Item点击控件冲突焦点冲突什么的在Android里面问题多多，在这里就要简单太多了。之前我曾尝试使用Android的方式去做，发现总是碰壁。无奈又要求助一波百度*（文档看的太少）*。在点击事件的时候，我们一般是给被点击View添加一个bindtap方法，后面写上方法名即可：bindtap=\"bindItemTap\"\r\n复制代码而如果这个View里面包含了其他的子View需要添加点击事件的时候，我们需要使用另一种写法了：catchtap=\"clickCollect\"\r\n复制代码这里的点击事件也很有趣，包括手指的手势都有涉及，包括手指点下去的时候、抬起来的时候、移动的时候等等，和Android的ACTION_DOWN及 ACTION_UP等异曲同工。####URL的限制， 不论什么请求必须Https 微信小程序对于网络请求有一定的限制，比如我们的玩Android是仅支持http的，但是微信是要求必须使用https请求才被许可，这也简单。我采用的方法是利用第三方搭建的网站进行url桥接。把网络管理类里面的baseUrl前面加上 wxapi.hotapp.cn/proxy/ ，然后拼上你在网站申请的key*（可以写死）*，然后拼上你http协议的url即可。提到微信的url限制，不得不说微信目前限制个人开发者和海外开发者使用webview打开第三方h5页面。所以，咱们在预览的时候只能用编译器去预览，想看具体的文章目前还是有限制的，我就不求赞助申请企业认证了。当然也欢迎有企业账户的基佬把代码fork过去给大家提供个福利*（别犯法哦）*。其他的就不多赘述了再一次感谢您花费时间看我啰嗦了这么久，觉得还不错可以 star star star 一波。微信小程序我并不打算深耕太多，后面会把重心转移到其他技术方面。如果您对本项目有什么想法欢迎 去提issue ，有兴趣可以自己参与进来迭代维护。祝您生活愉快！作者@samhaus2018 年 05月 01日"}
{"title": "微信小程序 - 选取搜索地点并且显示（map） ", "author": "Rolan", "pub_time": "2018-9-21 00:38", "content": "演示如下，使用时，你也许会配合它：腾讯地图路线规划wxml:1 <view class='address' bindtap='onChangeAddress'>2   <input class='choose-address' placeholder='请选取地点' value='{{chooseAddress}}'></input>3  </view>wxss:1 .choose-address{2   border: 1px solid #000;3 }js 1 Page({ 2   data: { 3     4   }, 5   //移动选点 6   onChangeAddress: function() { 7     var _page = this; 8     wx.chooseLocation({ 9       success: function(res) {10         _page.setData({11           chooseAddress: res.name12         });13       },14       fail: function(err) {15         console.log(err)16       }17     });18   }19 });"}
{"title": "小程序解决方案 Westore - 组件、纯组件、插件开发 ", "author": "Rolan", "pub_time": "2018-10-10 00:40", "content": "数据流转先上一张图看清 Westore 怎么解决小程序数据难以管理和维护的问题:非纯组件的话，可以直接省去 triggerEvent 的过程，直接修改 store.data 并且 update，形成缩减版单向数据流。Github: https://github.com/dntzhang/westore组件这里说的组件便是自定义组件，使用原生小程序的开发格式如下:Component({\r\n  properties: { },\r\n\r\n  data: { },\r\n\r\n  methods: { }\r\n})使用 Westore 之后:import create from '../../utils/create'\r\n\r\ncreate({\r\n  properties: { },\r\n\r\n  data: { },\r\n\r\n  methods: { }\r\n})看着差别不大，但是区别：Component 的方式使用 setData 更新视图create 的方式直接更改 store.data 然后调用 updatecreate 的方式可以使用函数属性，Component 不可以，如：export default {\r\n  data: {\r\n    firstName: 'dnt',\r\n    lastName: 'zhang',\r\n    fullName:function(){\r\n      return this.firstName + this.lastName\r\n    }\r\n  }\r\n}绑定到视图:<view>{{fullName}}</view>小程序 setData 的痛点:使用 this.data 可以获取内部数据和属性值，但不要直接修改它们，应使用 setData 修改setData 编程体验不好，很多场景直接赋值更加直观方便setData 卡卡卡慢慢慢，JsCore 和 Webview 数据对象来回传浪费计算资源和内存资源组件间通讯或跨页通讯会把程序搞得乱七八糟，变得极难维护和扩展没使用 westore 的时候经常可以看到这样的代码:使用完 westore 之后:上面两种方式也可以混合使用。可以看到，westore 不仅支持直接赋值，而且 this.update 兼容了 this.setData 的语法，但性能大大优于 this.setData，再举个例子：this.store.data.motto = 'Hello Westore'\r\nthis.store.data.b.arr.push({ name: 'ccc' })\r\nthis.update()等同于this.update({\r\n  motto:'Hello Westore',\r\n  [`b.arr[${this.store.data.b.arr.length}]`]:{name:'ccc'}\r\n})这里需要特别强调，虽然 this.update 可以兼容小程序的 this.setData 的方式传参，但是更加智能，this.update 会先 Diff 然后 setData。原理:纯组件常见纯组件由很多，如 tip、alert、dialog、pager、日历等，与业务数据无直接耦合关系。组件的显示状态由传入的 props 决定，与外界的通讯通过内部 triggerEvent 暴露的回调。triggerEvent 的回调函数可以改变全局状态，实现单向数据流同步所有状态给其他兄弟、堂兄、姑姑等组件或者其他页面。Westore里可以使用 create({ pure: true }) 创建纯组件（当然也可以直接使用 Component），比如 ：import create from '../../utils/create'\r\n\r\ncreate({\r\n  pure : true,\r\n  \r\n  properties: {\r\n    text: {\r\n      type: String,\r\n      value: '',\r\n      observer(newValue, oldValue) { }\r\n    }\r\n  },\r\n\r\n  data: {\r\n    privateData: 'privateData'\r\n  },\r\n\r\n  ready: function () {\r\n    console.log(this.properties.text)\r\n  },\r\n\r\n  methods: {\r\n    onTap: function(){\r\n      this.store.data.privateData = '成功修改 privateData'\r\n      this.update()\r\n      this.triggerEvent('random', {rd:'成功发起单向数据流' + Math.floor( Math.random()*1000)})\r\n    }\r\n  }\r\n})需要注意的是，加上 pure : true 之后就是纯组件，组件的 data 不会被合并到全局的 store.data 上。组件区分业务组件和纯组件，他们的区别如下：业务组件与业务数据紧耦合，换一个项目可能该组件就用不上，除非非常类似的项目业务组件通过 store 获得所需参数，通过更改 store 与外界通讯业务组件也可以通过 props 获得所需参数，通过 triggerEvent 与外界通讯纯组件与业务数据无关，可移植和复用纯组件只能通过 props 获得所需参数，通过 triggerEvent 与外界通讯大型项目一定会包含纯组件、业务组件。通过纯组件，可以很好理解单向数据流。小程序插件小程序插件是对一组 JS 接口、自定义组件或页面的封装，用于嵌入到小程序中使用。插件不能独立运行，必须嵌入在其他小程序中才能被用户使用；而第三方小程序在使用插件时，也无法看到插件的代码。因此，插件适合用来封装自己的功能或服务，提供给第三方小程序进行展示和使用。插件开发者可以像开发小程序一样编写一个插件并上传代码，在插件发布之后，其他小程序方可调用。小程序平台会托管插件代码，其他小程序调用时，上传的插件代码会随小程序一起下载运行。插件开发者文档插件使用者文档插件开发Westore 提供的目录如下:|--components\r\n|--westore  \r\n|--plugin.json  \r\n|--store.js创建插件:import create from '../../westore/create-plugin'\r\nimport store from '../../store'\r\n\r\n//最外层容器节点需要传入 store，其他组件不传 store\r\ncreate(store, {\r\n  properties:{\r\n    authKey:{\r\n      type: String,\r\n      value: ''\r\n    }\r\n  },\r\n  data: { list: [] },\r\n  attached: function () {\r\n    // 可以得到插件上声明传递过来的属性值\r\n    console.log(this.properties.authKey)\r\n    // 监听所有变化\r\n    this.store.onChange = (detail) => {\r\n      this.triggerEvent('listChange', detail)\r\n    }\r\n    // 可以在这里发起网络请求获取插件的数据\r\n    this.store.data.list = [{\r\n      name: '电视',\r\n      price: 1000\r\n    }, {\r\n      name: '电脑',\r\n      price: 4000\r\n    }, {\r\n      name: '手机',\r\n      price: 3000\r\n    }]\r\n\r\n    this.update()\r\n\r\n    //同样也直接和兼容 setData 语法\r\n    this.update(\r\n        { 'list[2].price': 100000 }\r\n    )\r\n  }\r\n})在你的小程序中使用组件：<list auth-key=\"{{authKey}}\" bind:listChange=\"onListChange\" />这里来梳理下小程序自定义组件插件怎么和使用它的小程序通讯:通过 properties 传入更新插件，通过 properties 的 observer 来更新插件通过 store.onChange 收集 data 的所有变更通过 triggerEvent 来抛事件给使用插件外部的小程序这么方便简洁还不赶紧试试 Westore插件开发模板 ！特别强调插件内所有组件公用的 store 和插件外小程序的 store 是相互隔离的。原理页面生命周期函数组件生命周期函数由于开发插件时候的组件没有 this.page，所以 store 是从根组件注入，而且可以在 attached 提前注入:export default function create(store, option) {\r\n    let opt = store\r\n    if (option) {\r\n        opt = option\r\n        originData = JSON.parse(JSON.stringify(store.data))\r\n        globalStore = store\r\n        globalStore.instances = []\r\n        create.store = globalStore\r\n    }\r\n\r\n    const attached = opt.attached\r\n    opt.attached = function () {\r\n        this.store = globalStore\r\n        this.store.data = Object.assign(globalStore.data, opt.data)\r\n        this.setData.call(this, this.store.data)\r\n        globalStore.instances.push(this)\r\n        rewriteUpdate(this)\r\n        attached && attached.call(this)\r\n    }\r\n    Component(opt)\r\n}总结组件 - 对 WXML、WXSS 和 JS 的封装，与业务耦合，可复用，难移植纯组件 - 对 WXML、WXSS 和 JS 的封装，与业务解耦，可复用，易移植插件 - 小程序插件是对一组 JS 接口、自定义组件或页面的封装，与业务耦合，可复用Star & Fork 小程序解决方案https://github.com/dntzhang/westoreLicenseMIT @dntzhang"}
{"title": "Serverless实战驾校小程序【考题练习】二 ", "author": "Rolan", "pub_time": "2018-10-11 00:32", "content": "准备工作做完后，今天我们从核心模块，分类与题目练习开始做。由于开发时间比较紧，这里主要写实习思路，与核心代码。image.png页面一、首页这里我们主要优先实现功能逻辑，UI后面调整，我们用iview 拖一个大致结构的页面。这里用了以下组件{  \"usingComponents\": {    \"i-tab-bar\": \"../../dist/tab-bar/index\",    \"i-tab-bar-item\": \"../../dist/tab-bar-item/index\",    \"i-grid\": \"../../dist/grid/index\",    \"i-grid-item\": \"../../dist/grid-item/index\",    \"i-grid-icon\": \"../../dist/grid-icon/index\",    \"i-grid-label\": \"../../dist/grid-label/index\",    \"i-tabs\": \"../../dist/tabs/index\",    \"i-tab\": \"../../dist/tab/index\"  }}页面二、专项练习页面这个页面，我们从数据库里取出数据，首先建立好数据表，这个表结构昨天有讲。我们导入一个CSV格式数据到表里CSV文件内容bSubjects,title 1,时间题 1,速度题 1,距离题 1,罚款题 1,记分题 1,标志题 1,标线题 1,手势题 1,信号灯 1,灯光题 1,仪表题 1,装置题 1,路况题 1,酒驾题 1,动画题 1,情景题 然后我们取出这里的数据，在小程序里面显示核心代码// 库文件const getQuestionTypeList=()=>{    return new Promise((resolve, reject) => {      const query = wx.Bmob.Query('questionType');      query.find().then(res => {          console.log(res)          resolve(res)      }).catch(err=>{        console.error(err)        reject(err)      })    });}// 页面js文件wechatApp-questions2/pages/topic/index.jsonLoad(e){    wx.u.getQuestionTypeList().then(r=>{      console.log(r,`k`)      this.setData({        result:r      })    })  },  // wxml文件  <i-panel title=\"题型列表\" hide-top>    <!-- <view style=\"padding: 15px;\">头部距离为 0 的 Panel</view> -->    <i-row>        <i-col wx:for=\"{{result}}\" span=\"12\" i-class=\"col-class\">            <i-panel bindtap=\"handleTabClick\" data-id=\"{{item.objectId}}\" class=\"cell-panel-demo\" title=\"\">                <i-cell title=\"{{item.title}}\" value=\"\">                     <i-icon type=\"enterinto\" slot=\"icon\" />                </i-cell>            </i-panel>        </i-col>    </i-row></i-panel>首页点击到分类，分类点击到题目页面，下一个是题目页面，这个页面是整个项目的核心， 所以的题目都在这个页面进行计算，判断。页面三、答题页面 这个页面会是最复杂的一个页面， 涉及到，计时，判断、记录历史等等操作。之前只想到模拟考试，没考虑到这种按照顺序练习， 第二次进入，可以继续之前的题目练习。 这里建个学习表，记录他的顺序练习相关数据，以下是数据表暂定的结构学习表 learning第一步：还是一样，用iview 复制出对应组件第二步：查询出此类别的题目， 并且默认显示一道题，点击下一题，显示数组下一个元素第三步：先做单选题，点击选择，判断是否正确， 如果正确，记录到结果对象 [{\" id \":\" XXX ', '0'}, {\" id \":\" XXX \", \"1\"}] ，0代表回答错误，1正确第四步：点击下一题计算进度条位置，判断当前是否选择了题目，否则提示请选择结果。目前做到这个一步，明天继续。作者：微信小程序开发 链接：https://www.jianshu.com/p/19283a793c60 來源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。"}
{"title": "io.Reader游标引发的血案 ", "author": "Rolan", "pub_time": "2018-10-12 00:05", "content": "背景线上运行了一个图片合成程序，默认的小程序二维码中奖是小程序LOGO，不满足需求，所以将微信小程序二维码和用户头像合成在一张图片。由于微信图片有时候返回的Content-Type不对应（比如内容是PNG的，头确是image/jpeg）所以使用jpeg/png/gif的顺序进行图片数据解析，哪个成功就返回解析结果。问题总是出现诸如 invalid JPEG format: missing SOI marker解决过程我去查看jpeg.Decode的源码，如下：func (d *decoder) decode(r io.Reader, configOnly bool) (image.Image, error) {\r\n    d.r = r\r\n\r\n    // Check for the Start Of Image marker.\r\n    if err := d.readFull(d.tmp[:2]); err != nil {\r\n        return nil, err\r\n    }\r\n    if d.tmp[0] != 0xff || d.tmp[1] != soiMarker {\r\n        return nil, FormatError(\"missing SOI marker\")\r\n    }\r\n...soiMarker常量soiMarker  = 0xd8 // Start Of Image.可以看到判断了第1个字节如果不是 0xff 或者第2个字节不是 0xd8 就报错。打印图片的bytes前几个字节如下：[]byte{0xff, 0xd8, 0xff, 0xe0, 0x0, 0x10}可以看到第1个字节和第2个字节满足要求，按理说不会出现这个问题，无奈只能求助于Google,搜索了invalid JPEG format: missing SOI marker 关键字出现一篇 Covert base64 string to JPG 引起了我的注意。打开看到答案You need to create a new reader for each decoder:pngI, errPng := png.Decode(bytes.NewReader(unbased))\r\n\r\n// ...\r\n\r\njpgI, errJpg := jpeg.Decode(bytes.NewReader(unbased))原来需要重新创建读取器，重新创建读取器后问题解决。后续抱着打破砂锅问到底的心态，查看了一下 bytes.Reader 的源码，发现游标读取完后并未重置// Read implements the io.Reader interface.\r\nfunc (r *Reader) Read(b []byte) (n int, err error) {\r\n    if r.i >= int64(len(r.s)) {\r\n        return 0, io.EOF\r\n    }\r\n    r.prevRune = -1\r\n    n = copy(b, r.s[r.i:])\r\n    r.i += int64(n)\r\n    return\r\n}Reader定义type Reader struct {\r\n    s        []byte\r\n    i        int64 // current reading index\r\n    prevRune int   // index of previous rune; or < 0\r\n}可以看到 r.i 就是游标了。问题圆满解决"}
{"title": "小程序源码反编译实战笔记 ", "author": "Rolan", "pub_time": "2018-10-12 00:21", "content": "分分钟上手小程序源码反编译最近在做微信小程序开发，看到一些做的比较有意思的小程序，想看一看他们的源码，于是研究了一下小程序源码反编译相关的技术。结合本次经历，总结如下。手机root要拿到小程序在手机上的源码包，需要有一台越狱的iphone或者一台拥有root权限的android机，正好我手里有一台闲置的小米4，就拿来用了，试过很多种方式给小米4root，差点搞成板砖机，一直在recorvy模式启动不了，最后尝试了小米官网的刷机方法，把系统刷成了开发版，完美root。小米4刷机教程： https://www.miui.com/shuaji-305.html手机刷机成功后，开启root权限，并打开USB调试模式小米4开发版开启root权限： http://www.miui.com/thread-9625466-1-1.htmlMIUI9开启USB调试： https://jingyan.baidu.com/article/49711c6196e728fa441b7c37.html电脑操作以 MacOS 操作系统为例，通过USB连接操作Android手机安装 adb 工具在 MacOS 系统上可以通过 brew 安装 adb 工具brew cask install android-platform-tools\r\n手机连电脑通过USB数据线将手机连接到电脑，并在手机端开启USB调试，通过下面的命令测试是否连接成功adb devices\r\n连接成功的情况下查看小程序源码进入 adb shell 模式adb shell\r\n切换到root权限su\r\n进入小程序源码目录先进入 MicroMsg 文件夹，通过 ls 命令查看文件夹，找到 63c92a20722afef36b525ecb04706c15 这样的文件夹（不同的微信登录用户，这个文件夹的名称不同），然后再进入 appbrand/pkg目录cd /data/data/com.tencent.mm/MicroMsg\r\nls\r\ncd 63c92a20722afef36b525ecb04706c15/appbrand/pkg\r\n查看小程序源码可以先执行 rm -rf ./* 删除掉当前目录下所有缓存的小程序源码包，然后通过手机端点击进入需要获取源码的小程序，再执行 ls -l 即可看到最新操作的小程序源码包rm -rf ./*\r\nls -l\r\n将小程序源码拷贝到手机SD卡cp _1038319936_4.wxapkg /sdcard\r\n新开一个终端窗口，将源码拷贝到电脑adb pull sdcard/_1038319936_4.wxapkg /data/weapp/a.wxapkg\r\n操作过程截图反编译源码下载 nodejs 版本的反编译工具并安装相关 npm 包git clone https://github.com/qwerty472123/wxappUnpacker.git\r\n\r\ncd wxappUnpacker\r\n\r\nnpm install esprima -g\r\nnpm install css-tree -g\r\nnpm install cssbeautify -g\r\nnpm install vm2 -g\r\nnpm install uglify-es -g\r\n反编译小程序源码node wuWxapkg.js /data/weapp/a.wxapkg\r\n最后进入反编译成功的文件，即可看到需要的小程序文件"}
{"title": "在小程序开发中使用 npm ", "author": "Rolan", "pub_time": "2018-10-12 00:37", "content": "本文介绍了如何在微信小程序开发中使用 npm 中包的功能，大大提高微信小程序的开发效率，同时也是微信小程序系列教程的视频版更新。微信小程序在发布之初没有对 npm 的支持功能，这也是目前很多前端开发人员在熟悉了 npm 生态环境后，对微信小程序诟病的地方。微信小程序在 2.2.1 版本后增加了对 npm 包加载的支持，使得小程序支持使用 npm 安装第三方包。微信小程序的功能更新最近更新的也非常给力，如之前给大家介绍的 微信小程序开发平台新功能「云开发」快速上手体验 。1. 在小程序中加载 npm 包微信小程序关于 npm 包的加载使用官方文档在 这里 ，此实战部分我们通过加载一个 npm 的第三方库 miniprogram-datepicker ，此类库用于实现公历与农历的日期选择功能，而微信小程序官方的组件只能简单地选择一个公历时间。在终端中定位到微信小程序的项目文件夹，通过 npm 的安装命令安装。此处请务必使用 –production 选项，可以减少安装一些业务无关的 npm 包，从而减少整个小程序包的大小。2. 构建 npm 包在微信小程序开发工具的「工具」菜单下点击「构建 npm」命令，进行 npm 包的构建，此构建可以将 npm 包构建成在小程序中可加载使用的包。为了帮助大家更好的理解发布 npm 包中提到的各种要求，这里简单介绍一下原理：首先 node_modules 目录不会参与编译、上传和打包中，所以小程序想要使用 npm 包必须走一遍“构建 npm”的过程，在最外层的 node_modules 的同级目录下会生成一个 miniprogram_npm 目录，里面会存放构建打包后的 npm 包，也就是小程序真正使用的 npm 包。构建打包分为两种：小程序 npm 包会直接拷贝构建文件生成目录下的所有文件到 miniprogram_npm 中；其他 npm 包则会从入口 js 文件开始走一遍依赖分析和打包过程（类似 webpack）。寻找 npm 包的过程和 npm 的实现类似，从依赖 npm 包的文件所在目录开始逐层往外找，直到找到可用的 npm 包或是小程序根目录为止。构建完成后还需要确认项目已勾选了「使用 npm 模块」。3. 在项目中使用第三方模块在我们之前实战项目中，在首页中测试下此 npm 模块的加载。<view class=\"doc-container\">\r\n  <view class=\"doc-title\">今日精选</view>\r\n\r\n  <datepicker value=\"\" bindchange=\"bindSolarChange\">\r\n    <button type=\"default\">公历</button>\r\n  </datepicker>\r\n  <datepicker value=\"\" chinese=\"true\" bindchange=\"bindLunarChange\">\r\n    <button type=\"default\">农历</button>\r\n  </datepicker>\r\n\r\n  <block wx:for=\"\" wx:key=\"\">\r\n    <view class=\"list\" data-para=\"\" bindtap=\"tapItem\">\r\n      <view class=\"view_preinfo\">\r\n        <text class=\"list_preinfo\"> / </text>\r\n      </view>\r\n      <text class=\"list_title\"></text>\r\n      <view>\r\n        <block wx:for=\"\" wx:key=\"\">\r\n          <text class=\"list_tag\" style=\"border: solid 1px ;\"></text>\r\n        </block>\r\n      </view>\r\n    </view>\r\n  </block>\r\n</view>在页面中布局完 datepicker 后，保存并完成项目的编译后，点击按钮即可看到组件的加载情况。"}
{"title": "微信小程序裁剪图片成圆形 ", "author": "Rolan", "pub_time": "2018-10-12 10:00", "content": "前言最近在开发小程序，产品经理提了一个需求，要求微信小程序换头像，用户剪裁图片必须是圆形，也在github上看了一些例子，一般剪裁图片用的都是方形，所以自己打算写一个小组件，可以把图片剪裁成圆形，主要思路就是使用canvas绘图，把剪裁的图片绘制成圆形，另外剪裁图片的窗口还可以移动放大缩小，这个功能就用了微信组件movable-view，好了，该说的也说完了，下面咱们开始撸代码。movable-view组件可移动的视图容器，在页面中可以拖拽滑动\r\n会有好多个属性，在这里不一一介绍，只说我们能用到的就可以。\r\n我们用到的属性主要有：direction：movable-view的移动方向，属性值有all、vertical、horizontal、nonescale：是否支持双指缩放，默认缩放手势生效区域是在movable-view内scale-min\t定义缩放倍数最小值scale-max\t定义缩放倍数最大值bindchange\t拖动过程中触发的事件，event.detail = {x: x, y: y, source: source}，其中source表示产生移动的原因，值可为touch（拖动）、touch-out-of-bounds（超出移动范围）、out-of-bounds（超出移动范围后的回弹）、friction（惯性）和空字符串（setData）bindscale\t缩放过程中触发的事件，event.detail = {x: x, y: y, scale: scale}，其中x和y字段在2.1.0之后开始支持返回主要用到的就是这几个值另外使用movable-view的时候必须在外边加一个movable-area的父元素，不然的话没有移动区域。movable-view 的可移动区域，属性只有：scale-area\t当里面的movable-view设置为支持双指缩放时，设置此值可将缩放手势生效区域修改为整个movable-area，是个boolean值，默认false截取区域的移动已经说完了，详情请看developers.weixin.qq.com/miniprogram…canvas绘图画布。该组件是原生组件可以绘制图像，分享朋友圈生成海报就经常用到这个属性，就简单的说下：在wxml中必须要有canvas这个标签，才可以绘制图像，而且要有canvas-id属性，代表canvas 组件的唯一标识符，还有许多API我就不一一介绍了，底下用的API代码当中都会用注释。详情请看微信小程序画布APIhttps://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.canvasGetImageData.html代码实现首先是选择图片wxml就是初始化一个按钮点击的时候选择图片，而且需要引入我们封装的截取图片组件，并把图片作为参数传进去，封装组件方法请看我另一篇文章juejin.im/post/5afcee…index.wxmlTip: 必须把canvas放到引入剪裁组件的wxml中，否则绘制不成功，因为canvas是原生组件脱离在 WebView 渲染流程外。<view class=\"container\">\r\n  <button wx:if=\"{{!imgSrc}}\" bindtap=\"getImgurl\"> 选择图片 button>\r\n  <view class=\"clip-box\" wx:if=\"{{imgSrc}}\">\r\n      <ClipImg imgSrc=\"{{imgSrc}}\">ClipImg>\r\n  view>\r\nview>\r\n<canvas canvas-id=\"myCanvas\" style=\"position:absolute; width:100%;height:100%;border: 1px solid red;left: -9999px; top: -9999px;\">canvas>\r\n复制代码index.json引入截取图片的组件{\r\n    \"component\": true,\r\n    \"usingComponents\": {\r\n        \"ClipImg\": \"../../component/clipImg/clipImg\"\r\n    }\r\n}\r\n复制代码index.js上传图片显示const app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    imgSrc: ''\r\n  },\r\n  //选择图片\r\n  getImgurl: function () {\r\n    wx.chooseImage({\r\n      count: 1, // 默认9\r\n      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success:  (res) => {\r\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n        const tempFilePaths = res.tempFilePaths;\r\n        //启动上传等待中...  \r\n        wx.showToast({  \r\n          title: '正在上传...',  \r\n          icon: 'loading',  \r\n          mask: true,  \r\n          duration: 1000 \r\n        }) \r\n        this.setData({\r\n          imgSrc: res.tempFilePaths\r\n        })\r\n      }\r\n    })\r\n  },\r\n  onLoad: function () {\r\n  }\r\n})\r\n复制代码接下来就是剪裁图片组件的封装首先是页面布局，也就是clipImg.wxml<view class=\"clip\">\r\n    <image class=\"head-img\" style=\"width:{{cropperW}}rpx;height:{{cropperH}}rpx\" src=\"{{imageUrl}}\">image>\r\n    <movable-area scale-area style=\"width:{{cropperW}}rpx;height:{{cropperH}}rpx\">\r\n        <movable-view bindchange=\"move\" bindscale=\"scale\" direction=\"all\" scale scale-min=\"0.5\" scale-max=\"1.8\">\r\n        movable-view>\r\n    movable-area>\r\n    <view class=\"btn\">\r\n        <text bindtap=\"cancel\">取消text>\r\n        <text bindtap=\"getImageInfo\">保存text>\r\n    view>\r\nview>\r\n复制代码大概就是这个样子上边的圆就是截取就是截取框。然后就是clipImg.js文件主要就是对图片截取的一些操作Component({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    imgSrc: {\r\n      type: 'String',\r\n      value: ''\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   * imageUrl string 初始化图片\r\n   * cropperW string 缩小图宽度\r\n   * cropperH  string 缩小图高度,\r\n   * img_ratio string  图片比例,\r\n   * IMG_W string 原图高度,\r\n   * IMG_H string 原图高度,\r\n   * left string 图片距离左边距离,\r\n   * top string 图片距离上边距离,\r\n   * clipW number 默认截取框\r\n   */\r\n  data: {\r\n    imageUrl: '',\r\n    cropperW: '',\r\n    cropperH: '',\r\n    img_ratio: '',\r\n    IMG_W: '',\r\n    IMG_H: '',\r\n    left: '',\r\n    top: '',\r\n    clipW: 200\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    //点击取消\r\n    cancel: function () {\r\n      var myEventDetail = {} // detail对象，提供给事件监听函数\r\n      var myEventOption = {} // 触发事件的选项\r\n      this.triggerEvent('myevent', myEventDetail, myEventOption)\r\n    },\r\n    //拖拽事件\r\n    move: function ({ detail }) {\r\n      this.setData({\r\n        left: detail.x * 2,\r\n        top: detail.y * 2\r\n      })\r\n    },\r\n    //缩放事件\r\n    scale: function ({ detail }) {\r\n      console.log(detail.scale)\r\n      this.setData({\r\n        clipW: 200 * detail.scale\r\n      })\r\n    },\r\n    //生成图片\r\n    getImageInfo: function () {\r\n      wx.showLoading({\r\n        title: '图片生成中...',\r\n      })\r\n      const img_ratio = this.data.img_ratio;\r\n      //要截取canvas的宽\r\n      const canvasW = (this.data.clipW / this.data.cropperW) * this.data.IMG_W\r\n      //要截取canvas的高\r\n      const canvasH = (this.data.clipW / this.data.cropperH) * this.data.IMG_H\r\n      //要截取canvas到左边距离\r\n      const canvasL = (this.data.left / this.data.cropperW) * this.data.IMG_W\r\n      //要截取canvas到上边距离\r\n      const canvasT = (this.data.top / this.data.cropperH) * this.data.IMG_H\r\n      // 将图片写入画布\r\n      const ctx = wx.createCanvasContext('myCanvas');\r\n      //绘制图像到画布\r\n      ctx.save(); // 先保存状态 已便于画完圆再用        \r\n      ctx.beginPath(); //开始绘制  \r\n      ctx.clearRect(0, 0, 1000, 1000)\r\n      //先画个圆      \r\n      ctx.arc(this.data.clipW / 2, this.data.clipW / 2, this.data.clipW / 2, 0, 2 * Math.PI, false)\r\n      ctx.clip();//画了圆 再剪切  原始画布中剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内    \r\n      ctx.drawImage(this.data.imageUrl, canvasL, canvasT, canvasW, canvasH, 0, 0, this.data.clipW, this.data.clipW); // 推进去图片        \r\n      ctx.restore(); //恢复之前保存的绘图上下文 恢复之前保存的绘图上下午即状态 可以继续绘制\r\n      ctx.draw(true, () => {\r\n        // 获取画布要裁剪的位置和宽度   \r\n        wx.canvasToTempFilePath({\r\n          x: 0,\r\n          y: 0,\r\n          width: this.data.clipW,\r\n          height: this.data.clipW,\r\n          destWidth: this.data.clipW,\r\n          destHeight: this.data.clipW,\r\n          quality: 0.5,\r\n          canvasId: 'myCanvas',\r\n          success: (res) => {\r\n            wx.hideLoading()\r\n            /**\r\n             * 截取成功后可以上传的服务端直接调用\r\n             * wx.uploadFile();\r\n             */\r\n            //成功获得地址的地方\r\n            wx.previewImage({\r\n              current: '', // 当前显示图片的http链接\r\n              urls: [res.tempFilePath] // 需要预览的图片http链接列表\r\n            })\r\n          }\r\n        })\r\n      })\r\n    }\r\n  },\r\n  ready: function () {\r\n    this.setData({\r\n      imageUrl: this.data.imgSrc[0]\r\n    })\r\n    //获取图片宽高\r\n    wx.getImageInfo({\r\n      src: this.data.imageUrl,\r\n      success: (res) => {\r\n        console.log('图片信息', res);\r\n        //图片实际款高\r\n        const width = res.width;\r\n        const height = res.height;\r\n        //图片宽高比例\r\n        const img_ratio = width / height\r\n        this.setData({\r\n          img_ratio,\r\n          IMG_W: width,\r\n          IMG_H: height,\r\n        })\r\n        if (img_ratio >= 1) {\r\n          //宽比较大，横着显示\r\n          this.setData({\r\n            cropperW: 750,\r\n            cropperH: 750 / img_ratio,\r\n          })\r\n        } else {\r\n          //竖着显示\r\n          this.setData({\r\n            cropperW: 750 * img_ratio,\r\n            cropperH: 750\r\n          })\r\n        }\r\n      } \r\n    })\r\n  }\r\n})\r\n复制代码到现在为止一个截取图片就完成了，可能会有些问题，比如截取的图片的框没有居中，自己可以再次封装这个组件，因为现在已经适合我们公司自己项目了。我们来预览下。另外这个组件支持双指放大截取框来截取图片，不过微信开发者工具不能展示，自己可以把代码下载下来，在自己手机上扫码查看效果。另外我把项目放到了github上边，希望小哥哥小姐姐们多多点赞，多多支持。使用的时候直接把component里边的组件直接引进去就行，有什么疑问可以在github底下留言问我，谢谢。点赞的小哥哥小姐姐最可爱，哈哈哈。。。项目地址github.com/Mr-MengBo/i…"}
{"title": "微信小程序如何开发跑马灯效果？ ", "author": "Rolan", "pub_time": "2018-10-15 00:06", "content": "跑马灯效果比较常见，一般做电商类的小程序，都会用到，所以代码君今天特地写一篇文章，来教一下大家，如何去实现跑马灯效果，下面是代码君实现的效果，可以先看一下！跑马灯效果的制作制作方式很简单，先方上代码，后面会对代码详细讲解一、wxml界面的实现<!-- 跑马灯效果  -->\r\n    <view class=\"example\">\r\n      <view class=\"marquee_box\">\r\n        <view class=\"marquee_text\" style=\"{{orientation}}:{{marqueeDistance}}px;font-size: {{size}}px;\">\r\n          <image src=\"{{adUrl}}\" class='ad-image' />{{text}}\r\n        </view>\r\n      </view>\r\n    </view>\r\n复制代码界面布局很简单，一个底部背景容器，加入一个广播图片和对应的跑马灯文字二、wxss样式.example {\r\n  display: block;\r\n  width: 100%;\r\n  height: 70rpx;\r\n  background-color: #f2f2f2;\r\n  line-height: 70rpx;\r\n}\r\n\r\n.marquee_box {\r\n  width: 100%;\r\n  position: relative;\r\n}\r\n\r\n.marquee_text {\r\n  white-space: nowrap;\r\n  position: absolute;\r\n  top: 0;\r\n  display: flex;\r\n  flex-direction: row;\r\n}\r\n\r\n.ad-image {\r\n  width: 40rpx;\r\n  height: 40rpx;\r\n  margin-right: 10rpx;\r\n  margin-top: 15rpx;\r\n}\r\n复制代码样式就这些，这里代码君要带着大家回顾一下以前教程里讲解的内容文字居中css样式要如何设置？只需要将属性height与line-height设置成一样高度即可display属性none:此元素不会被显示block：两个元素自动换行inline：两个元素靠在一起inherit：继承父类flex：多栏多列三、xxx.jsPage({\r\n  data: {\r\n     text: '51淘甄貨,一个可以省钱的购物平台',\r\n    marqueePace: 1,//滚动速度\r\n    marqueeDistance: 0,//初始滚动距离\r\n    size: 14,\r\n    orientation: 'left',//滚动方向\r\n    interval: 20, // 时间间隔\r\n    adUrl: '../../images/ic_home_msg.png',\r\n  },\r\n  onShow: function () {\r\n    // 页面显示\r\n    var that = this;\r\n    var length = that.data.text.length * that.data.size;//文字长度\r\n    var windowWidth = wx.getSystemInfoSync().windowWidth;// 屏幕宽度\r\n    that.setData({\r\n      length: length,\r\n      windowWidth: windowWidth,\r\n    });\r\n    that.runMarquee();// 水平一行字滚动完了再按照原来的方向滚动\r\n  },\r\n runMarquee: function () {\r\n    var that = this;\r\n    var interval = setInterval(function () {\r\n      //文字一直移动到末端\r\n      if (-that.data.marqueeDistance < that.data.length) {\r\n        that.setData({\r\n          marqueeDistance: that.data.marqueeDistance - that.data.marqueePace,\r\n        });\r\n      } else {\r\n        clearInterval(interval);\r\n        that.setData({\r\n          marqueeDistance: that.data.windowWidth\r\n        });\r\n        that.runMarquee();\r\n      }\r\n    }, that.data.interval);\r\n  }\r\n})\r\n复制代码js里面需要讲解的比较多1. setInterval 计时器如何使用？setInterval(function(){\r\nconsole.log(\"interval\")\r\n},1000)\r\n复制代码这个方法是微信小程序的api，直接使用即可，和正常的定时器一样，setInterval需要传入两个参数，一个是回调的方法，另一个是每隔多久执行一次，在此项目中，我们用的是字段参数interval，值设置为202. settimeout和setinterval()这两个都是腾讯提供的API，他们有什么区别吗？settimeout隔一段时间执行函数且执行一次，场景是我们可能希望一个任务隔一段时间后再执行etinterval()函数是 每 隔一段时间便执行，就是会一直循环执行，如果想停止的话可以使用clearinterval3.跑马灯实现原理第一步：计算跑马灯文字长度第二步：每隔一段时间，移动一点距离，产生移动第三步：当移出屏幕，重置跑马灯的距离为屏幕宽度，然后就可以继续循环第一步操作了根据代码君说的这几步，读者可以去一一对照代码，方法函数runMarquee里面的代码逻辑就是执行以上三步，在此代码君就不过多解释了总结以上就是跑马灯效果的整个流程，原理也不是很难，一个计时器，轻松就可以实现，如果还想学习更多教程，关注《代码集中营》公众号获取最新教程"}
{"title": "微信小程序及各种平台对接常用可逆加密算法aes256 ", "author": "Rolan", "pub_time": "2018-10-15 00:21", "content": "不同程序之间经常会交换数据,我们经常采用的套路是:假设要传输的信息是json,我们假设其为json_data,通过http传递信息为json_data_encode=json_data&sign=md5(json_data+key)接收方通过验证sign就知道内容有没有被篡改.但是,这样json_data作为明码传送会让我们不太开心,所以今天的我们要介绍的aes256出马了,他是一强度很高的可逆加密算法!aes256加密出来的内容是二进制的,不好通过http协议传输,所以我们再配合上base64转成ascii码加密前,aes256要求字节数必须是32字节的倍数,所以使用pkcs7进行填充可以解决问题..介绍完原理,直接贴代码写了3个版本,openresty及python和php的...请查收local aes = require 'resty.aes' local base64_encode = ngx.encode_base64 local base64_decode = ngx.decode_base64 local key = \"a12e93c9edadeaa47eb1aeabe27dabef\" local iv = \"a12e93c9edadeaa4\" -- AES 128 CBC with IV and no SALT local cipher = aes.cipher(256,\"cbc\") local aes_256_cbc_with_iv = aes:new(key,nil,cipher,{iv=iv}) local function decrypt(input)     input = base64_decode(input)     input = aes_256_cbc_with_iv:decrypt(input)     -- 取最后一个字符的ascii值     --local padding = string.byte(input,-1)     --return string.sub(input,-padding)     return input end local function pkcs7_padding(text)     local text_length = string.len(text)     local amount_to_pad = 32 - (text_length % 32)     if amount_to_pad == 0 then         amount_to_pad = 32     end     local pad = string.char(amount_to_pad) return text .. string.rep(pad,amount_to_pad) end local function encrypt (text)     text = pkcs7_padding(text)     text = aes_256_cbc_with_iv:encrypt(text)     return base64_encode(text) end print(decrypt(encrypt('linbc')))接着是python版本的#!/usr/bin/env python# -*- coding: utf-8 -*-import base64from Crypto.Cipher import AESimport binasciiimport StringIOclass PKCS7Encoder(object):    '''    RFC 2315: PKCS#7 page 21    Some content-encryption algorithms assume the    input length is a multiple of k octets, where k > 1, and    let the application define a method for handling inputs    whose lengths are not a multiple of k octets. For such    algorithms, the method shall be to pad the input at the    trailing end with k - (l mod k) octets all having value k -    (l mod k), where l is the length of the input. In other    words, the input is padded at the trailing end with one of    the following strings:             01 -- if l mod k = k-1            02 02 -- if l mod k = k-2                        .                        .                        .          k k ... k k -- if l mod k = 0    The padding can be removed unambiguously since all input is    padded and no padding string is a suffix of another. This    padding method is well-defined if and only if k < 256;    methods for larger k are an open issue for further study.    '''    def __init__(self, k=16):        self.k = k    ## @param text The padded text for which the padding is to be removed.    # @exception ValueError Raised when the input padding is missing or corrupt.    def decode(self, text):        '''        Remove the PKCS#7 padding from a text string        '''        nl = len(text)        val = int(binascii.hexlify(text[-1]), 16)        if val > self.k:            raise ValueError('Input is not padded or padding is corrupt')        l = nl - val        return text[:l]    ## @param text The text to encode.    def encode(self, text):        '''        Pad an input string according to PKCS#7        '''        l = len(text)        output = StringIO.StringIO()        val = self.k - (l % self.k)        for _ in xrange(val):            output.write('%02x' % val)        return text + binascii.unhexlify(output.getvalue())# 使用256位的AES，Python会根据传入的Key长度自动选择，长度为16时使用128位的AESkey = 'a12e93c9edadeaa47eb1aeabe27dabef'mode = AES.MODE_CBC#iv = '1234567812345678'  # AES的CBC模式使用IViv = 'a12e93c9edadeaa4'  # AES的CBC模式使用IVencoder = PKCS7Encoder()text = \"This is for test.\"def encrypt(data):    encryptor = AES.new(key, AES.MODE_CBC, iv)    padded_text = encoder.encode(data)    encrypted_data = encryptor.encrypt(padded_text)    return base64.b64encode(encrypted_data)def decrypt(data):    cipher = base64.b64decode(data)    decryptor = AES.new(key, AES.MODE_CBC, iv)    plain = decryptor.decrypt(cipher)    return encoder.decode(plain)#encrypted_text = encrypt(text)encrypted_text = 'MD1ZOvuyvut4VEed4rf+8YKaOHyECJK/RWLcfVsJwjAEZp8Hhi1zi7oH3PLSygjFCAxCRJqMBzm/qhreznkg34Vgbho+zwprTgl4M0c0lRkvLzWzXmSYG8pcqth1qnbNSwQeS3MPuofgVXR0SGMTIzicCXDlmwQV9uvIJekgES2LMse4pVndcrftI9f6UbIiT085DhAaiV9yGsV3r4FES+LnwP9ZNi58TButNC9owyKh9RuRn7z04LfNy++7iLjzk/HurOkBkJewHSchLER+pK94qhg6Lj8mW7dl+y5j3wbXY9SodNK+S8LDRYCa1JyZ/w8rffUK8YCY+jCT3ZmV8G5vdUENTqsrB4jX87C+XQCY9WEG+VQ5MK5XlhhvMPZyn2NLZUi6gW1HjqE6i/uefzq/LFl47cL2Hmr/cLbfI5rF+d1hMAIZGNnRxjYkVVvipEwRSlkD47ZVFLiWRKPusB7Lke3mnGJ1O+5eQnREL7Q/xpRT+3JuCcOqZIZJFFrJXMj9CXsJGMXxFkfnKT3UAhOi/lRA65Vwt1BEswHuZzLLHquyEYQMc3cOW1vy1Fv4zpYkjHYmxB1g50gwVryrEW2kY58sDdxwDYua3jLwERk='clean_text = decrypt(encrypted_text)print \"encrypted_text:\", encrypted_textprint \"clean_text: \", clean_text再来个php版本的<?php//function aes256EcbPkcs7PaddingEncrypt($key, $data) {//    $padding = 16 - (strlen($data) % 16);//    $data .= str_repeat(chr($padding), $padding);//    return mcrypt_encrypt(MCRYPT_RIJNDAEL_256, hash('SHA256', $key, true), $data, MCRYPT_MODE_ECB);//}////function aes256EcbPkcs7PaddingDecrypt($key, $data) {//    $data = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, hash('SHA256', $key, true), $data, MCRYPT_MODE_ECB);//    $padding = ord($data[strlen($data) - 1]); //    return substr($data, 0, -$padding); //}$txt=\"MD1ZOvuyvut4VEed4rf+8YKaOHyECJK/RWLcfVsJwjAEZp8Hhi1zi7oH3PLSygjFCAxCRJqMBzm/qhreznkg34Vgbho+zwprTgl4M0c0lRkvLzWzXmSYG8pcqth1qnbNSwQeS3MPuofgVXR0SGMTIzicCXDlmwQV9uvIJekgES2LMse4pVndcrftI9f6UbIiT085DhAaiV9yGsV3r4FES+LnwP9ZNi58TButNC9owyKh9RuRn7z04LfNy++7iLjzk/HurOkBkJewHSchLER+pK94qhg6Lj8mW7dl+y5j3wbXY9SodNK+S8LDRYCa1JyZ/w8rffUK8YCY+jCT3ZmV8G5vdUENTqsrB4jX87C+XQCY9WEG+VQ5MK5XlhhvMPZyn2NLZUi6gW1HjqE6i/uefzq/LFl47cL2Hmr/cLbfI5rF+d1hMAIZGNnRxjYkVVvipEwRSlkD47ZVFLiWRKPusB7Lke3mnGJ1O+5eQnREL7Q/xpRT+3JuCcOqZIZJFFrJXMj9CXsJGMXxFkfnKT3UAhOi/lRA65Vwt1BEswHuZzLLHquyEYQMc3cOW1vy1Fv4zpYkjHYmxB1g50gwVryrEW2kY58sDdxwDYua3jLwERk=\";$txt=base64_decode($txt);$key=\"a12e93c9edadeaa47eb1aeabe27dabef\";$iv ='a12e93c9edadeaa4';$module = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, '');mcrypt_generic_init($module, $key, $iv);$data = mdecrypt_generic($module, $txt);mcrypt_generic_deinit($module);mcrypt_module_close($module);$padding = ord($data[strlen($data) - 1]); $result = substr($data, 0, -$padding); echo $result;exit();?>php果然是...很省事的语言..看他多简短啊."}
{"title": "小程序国际化实现机制 ", "author": "Rolan", "pub_time": "2018-10-15 00:34", "content": "需求可手动设置使用语言根据不同的语言显示不同的语言文字（目前是支持中英文，如需其他语言，可直接配置即可） 如果没有配置相应语言的信息，则使用默认的数据 国际化分为文字和图片（有的图片上有文字信息）两类 限制因素小程序2m的限制所以图片网络化\" style=\"margin: 20px 0px; font-family: \"PingFang SC\", \"Hiragino Sans GB\", \"Helvetica Neue\", \"Microsoft Yahei\", \"WenQuanYi Micro Hei\", sans-serif; font-weight: 500; line-height: 40px; color: rgb(44, 62, 80); text-rendering: optimizeLegibility; font-size: 21px; background-color: rgb(249, 249, 245);\">因小程序2M的限制，所以图片网络化地图上的图片（如markers、controls、polyline等），不能使用网络图片，只能使用本地图片；所以图片的话分为本地图片和网络图片两种实现机制目录结构信息res │ resUtils.js │ ├─values │ img.js │ strings.js│ ├─values_en │ img.js │ strings.js │└─values_zh_CN strings.js values中是默认的是数据配置，values_en是英文坏境下的配置，values_zh_CN中文简体环境下的配置 后面如果需要配置其他的语言（如zh_TW，中文繁体，台湾地区），只需要新建文件名 values_zh_TW即可 resUtils.js是国际化的核心代码位置，这个文件会根据不同的语言来引用引用对应的文件； 首次如果没有设置过语言，或跟从当前手机的语言环境，后面如果设置过语言的话，跟从设置的语言来（暂定，具体的需求还未出） 具体配置文字国际化，直接在对应的环境下strings.js中添加要用的文字信息，文件会自动导出module.exports = {  LOGIN_STATUS_INVALID: '登录失效',  LOGIN_LOG_AGAIN: '请重新登录',}module.exports = {  LOGIN_STATUS_INVALID: 'Login status invalid',  LOGIN_LOG_AGAIN: 'Log in again',}图片国际化（分为本地和网络图片两种）； 网络图片直接调用getImg('drawableName.png')，即可； 本地图片，使用绝对路径即可/** * 默认环境图片配置 * @author Shirley.jiang  */const ICON_URL = 'https://***';let env = 'zh_CN';let getImg = (name) => {  return ICON_URL + '/' + env + '/' + name;}module.exports = {  IC_BTN_PHONE: getImg('btn_phone.png'), // 网络图片  ICON_LOCATION: '/imgs/icon_location.png', // 本地图片}/** * en环境图片配置 * @author Shirley.jiang  */const ICON_URL = 'https://***';let env = 'en';let getImg = (name) => {  return ICON_URL + '/' + env + '/' + name;}module.exports = {  IC_CHANGE_LANGUAGE: getImg('ic_change_language.png')};使用方式const resUtils = require('../../res/resUtils.js'); // 引入resUtils.strings.LOGIN_STATUS_INVALID; // 文字调用resUtils.imgs.IC_CHANGE_LANGUAGE； // 图片调用注意事项因wxml 文件不能应用js文件，所以数据全部通过data进行中转 data的加载比生命周期要早，导致切换语言的时候，data数据没有更新；所以在Page和Component中的ready方法之后，手动setData一次（因未找到更好的解决方案，暂定这种方式） 附带[resUtils.js]代码const localStorage = require('../utils/LocalStorage.js');/*** 国际化* @author Shirley.jiang*/class ResUtils {  static mInstance;  mStrings = {};  mImgs = {};  mEnv;  static getInstance() {    if (!ResUtils.mInstance) {      ResUtils.mInstance = new ResUtils();    }    return ResUtils.mInstance;  }  init(env) {      this.mEnv = env;      this.initStrings();          this.initImgs();  }   /**   * 引用字符配置   */  initStrings() {       this.mStrings = {};       let strings;       let defaultStrings;       try {      strings = require('./values_' + this.mEnv + '/strings.js');   } catch (err) { }       try {      defaultStrings = require('./values/strings.js');   } catch (err) { }       // 初始化默认的数据   for (let key in defaultStrings) {             if (!defaultStrings.hasOwnProperty(key)) {                   continue;       }             this.mStrings[key] = defaultStrings[key];   }       // 如果当前语言文件中定义的有，则直接覆盖   for (let key in strings) {             if (!this.mStrings.hasOwnProperty(key)) {                   continue;       }             this.mStrings[key] = strings[key];    }  }     /**   * 引用图片配置   */  initImgs() {       this.mImgs = {};       let imgs;       let defaultImgs;       try {      imgs = require('./values_' + this.mEnv + '/img.js');    } catch (err) { }       try {      defaultImgs = require('./values/img.js');    } catch (err) { }       // 初始化默认的数据   for (let key in defaultImgs) {             if (!defaultImgs.hasOwnProperty(key)) {                   continue;       }             this.mImgs[key] = defaultImgs[key];    }        // 如果当前语言文件中定义的有，则直接覆盖    for (let key in imgs) {              if (!this.mImgs.hasOwnProperty(key)) {                    continue;        }              this.mImgs[key] = imgs[key];    }  }     /**   * 切换语言   * @param {string} env 语言值   */  changeLanguage(env) {    localStorage.setEnv(env);        this.init(env);  }}/*** zh_CN 中文* zh_TW 中文繁体(台湾)* en 英文环境*/let env = localStorage.getEnv();ResUtils.getInstance().init(env);module.exports = ResUtils.getInstance();感谢《小程序开发一群》的Shirley.jiang投稿。"}
{"title": "小程序产品设计中的坑 ", "author": "Rolan", "pub_time": "2018-10-16 00:01", "content": "本文系统地罗列了微信小程序在产品设计上的出现的问题，并提出了相应的建议。资质不是所有功能都可以做，根据不同主体，会有不同的开放类目。主体分为「非个人主体」「个人主体」「海外主体」。有些类目需要有资质，比如社交类（包括社区、笔记等），都要 ICP 证。如果做了功能提交审核，发现的话会被拒绝，要求添加相关分类。官方文档： 小程序开放的服务类目对策：做服务端开关，审核时把功能隐藏（暂时貌似没有程序静态检查，只有人工审核），审核后再打开，但要承担被下架的风险。虚拟支付18年5月，由于苹果公司要求，iOS的小程序虚拟商品支付被禁止，即内容付费、工具服务类等，不包括外卖、电商这些；如果被发现，会屏蔽支付接口。对策：加入实体商品的性质，比如购买课程变成购买课程+书，加入收货地址等信息。模版消息推送可以给用户推送模版消息，会在「服务通知」里提醒，对留存比较有帮助（唤起用户）。有次数和时间限制，两种方式可以获得下发次数：支付：每次支付有 3 条下发次数，可以在 7 天内推送。提交表单：每次提交有 1 条下发次数，可以在 7 天内推送。官方文档： 模版消息大部分小程序都没有支付，主要靠提交表单，即需要用 <form/> 组件，让用户手动触发确认。常见做法会把 <form/> 伪装成一个列表项、某个按钮等，用户在使用过程中就获得了下发次数，但有违规风险。Tab bar 的 action button有的产品想要在 tab bar 加上 action button，比如：发布内容、新建文章等。但小程序原生 tab bar 目前不支持跳转新页面，只支持在当前打开页面。而如果自己实现 tab bar，性能会很差（切换 tab 时卡顿、页面闪烁）。有种做法，依然用原生 tab bar，但把 icon 素材做成 action button 的样式，然后在当前打开页面，列出一些选项让用户选择，再进入子页面。比如可以参考「美篇」的开始创作，先让用户选择文字、图片、视频，然后再进入文章编辑的子页面。自定义导航栏例如「知乎热榜」小程序，搜索框在导航栏。怎么做到的？其实是微信版本 6.6.0 后支持的特性，navigationStyle 可以设置为 custom，设置后顶栏就消失了，页面会自动顶到最顶部。所以「知乎热榜」那个搜索栏不是属于顶栏，而是属于页面内容，这下就好理解了。 ​​​​官方文档： 全局配置 – windowWebview小程序中可以使用 webview 组件，直接把 mobile web 套到小程序里，比如「多抓鱼」就是以 webview 为主的。好处：节省工作量，已有的 mobile web 不用重复开发。不需要等审核，随时部署更新。直接兼容一些小程序不支持的原生标签，比如 <pre/>。坏处：一个页面里只能有一个 <webview/> 组件，不能有其它。比如想用原生的 <button/> 来调起支付、分享，就不可以。只有绑定为业务域名的 url 才能跳转，不可以随便打开什么网页，上限 20 个。其它杂七杂八绑定的服务器域名，需要国内 ICP 备案，所以想做个 dribbble 客户端，直接利用 dribbble API 是不行的，只能想办法用自己服务器做数据转发。小程序之间可以互相跳转，但必须绑定在同一公众号下，而且具体跳转的是哪个小程序、哪个页面，要手动配置小程序 AppID 和路径。不能长按别二维码，也没办法下载 app。如果需要绑定手机号，可以使用小程序的 获取手机号 接口，调的是微信绑定了的手机号，很方便。作者：刘英滕链接：https://www.jianshu.com/p/f36e0aceed98本文由 @刘英滕 授权发布于人人都是产品经理，未经作者许可，禁止转载。题图来自Unsplash，基于CC0协议"}
{"title": "mp-redux：解耦小程序中的业务与视图，让测试更容易 ", "author": "Rolan", "pub_time": "2018-10-16 00:34", "content": "项目地址：点我，欢迎star和issue\r\nmp-redux\r\n一个用于小程序和轻量级H5应用的状态管理工具， 使用方法是一个简化版本的Redux。之所以是适用于轻量级应用，主要是因为没有实现组件间的数据共享。因此不适合于复杂，庞大的前端应用。\r\n是否你需要使用它？\r\n如果你也和我有同样的困惑，那么你就该尝试一下：\r\n\r\n代码耦合严重，业务代码重复，往往改一处就会引起诸多功能也要跟着修改\r\n业务逻辑都写在视图逻辑层，但是有苦于没有办法将业务代码剥离\r\n代码越来越臃肿不堪\r\n对老代码不敢碰，会影响很多业务逻辑\r\n\r\n为什么借鉴redux\r\n\r\n用为redux是框架无关的，所以具有更好的可移植性，当然我这里在内部还是做了一些\"猥琐\"处理来兼容多平台\r\n单一数据源，让状态更容易被跟踪\r\n将业务逻辑与视图层分离，让代码更清晰，耦合更低\r\n状态都应该放在页面的根容器去管理，分发到各个子组件。以便更好的控制业务逻辑\r\n业务逻辑都放入model中，而model都是纯函数，让测试更加容易\r\n\r\n如何使用？\r\n拷贝 /mp-redux/index.js文件到项目中引入即可。开包即用。\r\n为什么没有使用npm?\r\n懒\r\napi使用方法\r\n\r\n在系统入口我们必须初始化store\r\n\r\n  const mpState = require('./mp-redux/index.js');\r\n  const userInfo = require('./model/userinfo.js');\r\n  const logs = require('./model/logs.js');\r\n\r\n  mpState.createStore({\r\n    logs, // 这些model 就是redux的reduce，必须是纯函数，并且需要返回一个纯对象\r\n    userInfo // 这些model 就是redux的reduce，必须是纯函数，并且需要返回一个纯对象\r\n  }, 'onShow') // 第二个参数是劫持的生命周期函数，这是为了解决不同平台的差异性问题导致的。后期会考虑优化\r\n复制代码\r\n创建model\r\n\r\n  // model 就是数据模型，是根据业务而来的\r\n  // model/userinfo.js\r\n  const actions = require('./../action/logs.js'); // 这里同样采用了redux的action机制\r\n\r\n  const initState = {\r\n    logs: []\r\n  }\r\n\r\n  module.exports = function (state = initState, action = {}) {\r\n    const newState = { ...state };\r\n    switch (action.type) {\r\n      case actions.addLogs:\r\n        const now = new Date();\r\n        newState.logs.push({\r\n          time: now.getHours() + \":\" + now.getMinutes() + \":\" + now.getSeconds(),\r\n          value: action.data\r\n        });\r\n        return newState;\r\n      case actions.clearLogs:\r\n        newState.logs = [];\r\n        return newState;\r\n      default:\r\n        return newState;\r\n    }\r\n  }\r\n  // action/userinfo.js\r\n  module.exports = {\r\n    addLogs: 'LOGS_ADD',\r\n    clearLogs: 'LOGS_CLEAR'\r\n  }\r\n复制代码\r\n在Page中使用\r\n\r\n  // 使用connect来注入需要订阅的状态，并且mp-redux会在页面对象中自动注入dispatch方法 \r\n  const mpState = require('./../../mp-redux/index.js');\r\n  const util = require('../../utils/util.js');\r\n  const logActions = require('./../../action/logs.js');\r\n\r\n  Page(mpState.connect((state) => {\r\n    return {\r\n      userInfo: state.userInfo.userInfo,\r\n      logs: state.logs.logs\r\n    }\r\n  },\r\n  { // 在这里所有的业务数据都保存在store中，所以页面如果只有业务数据的话，是不需要data属性的。\r\n    clearLogs() {\r\n      this.dispatch({ // 通过dispatch方法来发出action，从而更新store中的数据\r\n        type: logActions.clearLogs\r\n      })\r\n    }\r\n  }))\r\n复制代码\r\n更容易被测试的业务代码\r\n从上面我们将业务数据声明到model中，而所有的业务数据更新以及业务数据更新的逻辑都在model中完成(参考/model/logs.js)。而model都是纯函数，因此业务代码更加容易被测试。\r\n\r\n  // 不要吐槽，，，，，，我第一次写测试用例。(-_-)\r\n  const actions = require('./../action/logs.js');\r\n  const model = require('./../model/logs.js');\r\n\r\n  test('1. init logs data', () => {\r\n    expect(model()).toEqual({\r\n      logs: []\r\n    })\r\n  })\r\n\r\n  test('2. add new log into empty logs', () => {\r\n    const newState = model(undefined, {\r\n      type: actions.addLogs,\r\n      data: \"Test new log\"\r\n    });\r\n\r\n    expect({\r\n      value: newState.logs[0].value,\r\n      len: newState.logs.length\r\n    }).toEqual({\r\n      value: \"Test new log\",\r\n      len: 1\r\n    });\r\n  })\r\n\r\n  test('3. add new log into logs', () => {\r\n    const newState = model({logs: [{time: '00:00:00', value: 'the first log'}]}, {\r\n      type: actions.addLogs,\r\n      data: \"the second log\"\r\n    });\r\n\r\n    expect({\r\n      log1: newState.logs[0].value,\r\n      log2: newState.logs[1].value,\r\n      len: newState.logs.length\r\n    }).toEqual({\r\n      log1: \"the first log\",\r\n      log2: \"the second log\",\r\n      len: 2\r\n    });\r\n  })\r\n\r\n  test('4. clear all logs', () => {\r\n    const newState = model({ logs: [\r\n      { time: '00:00:00', value: 'log1' }, \r\n      { time: '00:00:00', value: 'log2' }\r\n      ] }, {\r\n        type: actions.clearLogs\r\n      });\r\n\r\n    expect({\r\n      len: newState.logs.length\r\n    }).toEqual({\r\n      len: 0\r\n    });\r\n  })\r\n复制代码因为互联网产品都是toC业务，UI基本上每天都在变化，但是业务的变化其实是很小的。我们通过将业务建模，在前端构建业务数据模型。而这些模型是可以预知的。因此也就可测试。\r\n而对于一些互联网产品，前端测试是一件非常繁琐而复杂的事情。因此这个简单的方案大大的降低了前端代码变动引起的风险，而增加的工作量也并不是很大。可以一定程度上降低业务代码的回归测试成本。作者：YaHuiLiang(Ryou)链接：https://juejin.im/post/5bbb315d6fb9a05cf039ffed来源：掘金"}
{"title": "在小程序开发中使用 npm ", "author": "Rolan", "pub_time": "2018-10-17 00:11", "content": "微信小程序在 2.2.1 版本后增加了对 npm 包加载的支持，使得小程序支持使用 npm 安装第三方包。1. 在小程序中加载 npm 包npm install miniprogram-datepicker --production\r\nnode_modules可以 在小程序根目录下，也可以存在于小程序根目录下的各个子目录中。但是不可以 在小程序根目录外。使用--production选项，可以减少安装一些业务无关的 npm 包，从而减少整个小程序包的大小。2. 构建 npm 包在微信小程序开发工具的「工具」菜单下点击「构建 npm」命令，进行 npm 包的构建，此构建可以将 npm 包构建成在小程序中可加载使用的包。node_modules 目录不会参与编译、上传和打包中，所以小程序想要使用 npm 包必须走一遍“构建 npm”的过程，在最外层的 node_modules 的同级目录下会生成一个 miniprogram_npm 目录，里面会存放构建打包后的 npm 包，也就是小程序真正使用的 npm 包。构建打包分为两种：小程序 npm 包会直接拷贝构建文件生成目录下的所有文件到 miniprogram_npm 中；其他 npm 包则会从入口 js 文件开始走一遍依赖分析和打包过程（类似 webpack）。寻找 npm 包的过程和 npm 的实现类似，从依赖 npm 包的文件所在目录开始逐层往外找，直到找到可用的 npm 包或是小程序根目录为止。构建完成后还需要确认项目已勾选了「使用 npm 模块」。3.使用npm包js 中引入 npm 包：const package = require('packageName')\r\n使用 npm 包中的自定义组件：{\r\n    \"usingComponents\": {\r\n      \"datepicker\": \"miniprogram-datepicker\"\r\n    }\r\n}\r\nminiprogram-datepicker组件运行效果其他微信小程序npm支持文档：https://developers.weixin.qq...."}
{"title": "9块钱部署一个小程序 ", "author": "Rolan", "pub_time": "2018-10-17 00:11", "content": "小程序制作和部署从本质上是和其他的网站是一样的，需要域名、服务器空间和数据库。域名就是你们家的地址，服务器空间就是你们家房子，数据库就是你们家的保险柜。但是小程序和网站又有不同，小程序的前端部分是需要通过微信开发工具上传到微信的服务器上，就是说你们家的装潢都在微信的服务器上。当然你也可以把小程序的全部代码上传到自己的服务器上去。小程序的制作流程第一步：注册小程序https://mp.weixin.qq.com/按步骤注册小程序，获取appId和appSecret。第二步：微信开发工具你可以下微信的demo，了解小程序的前端和后端的开发结构。小程序前端包括的js,json,wxml,wxss.对应到网页就是js,html,css。微信开发里面有很多坑，先说个简单的微信授权吧，其他的以后说。第三步：微信的后台处理购买主机建站会获得一个可用的无备案的域名。但是里面的空间不能用ci框架，ci框架需要配置nginx来做路由设置。9块钱购买的空间里面不支持设置nginx。而且这个空间会隔几个小时让你输入密码，如果你是开发做实验，这个空间是足够的。如果你是自己开发，你可能要买一些好的服务器空间。可以自己操作里面的nginx。第四步：微信的提交体验和开发版点击微信开发者工具的上传按钮可以把你的版本上传到线上作为体验版本。然后可以提交审核变成线上版本。总结：开发部署练习9块钱就行！"}
{"title": "尝试解决微信小程序分页最后setData数据太大限制的问题 ", "author": "Rolan", "pub_time": "2018-10-17 00:43", "content": "前些天，突然接到用户的大量反馈，我们的小程序频繁出现闪退，崩溃的现象。如图，于是马上着手追查问题，首先确定了导致闪退的页面。是在一个有长列表的页面，当上拉加载更多，翻页翻多几页的时候就导致闪退了。经过重重排查（时间问题，这里就不详细描述排查的方法了，大多数用的都是缩小范围排除法啦），最后终于确定了问题所在，原来是在列表中，同事最近新加上的css3动画所致，这里的列表是循环渲染的一个组件，组件中的一个弹窗的弹出和收起，使用动画，但是这里没有加上wx:if,导致了循环渲染该动画，所以翻页翻着翻着就挂掉了。 确定了问题，就很好办了，加上条件判断，只有需要的时候，才渲染弹出弹窗。真机调试，暴力狂刷数据，发现闪退的现象不再出现了，闪退问题解决，然而高兴不到三分钟，又出问题了，发现翻页到十几页的时候，再也刷不动后面的数据了，明明是还有更多数据的。再在开发工具上看查看数据，结果控制台报了这么一个错在真机上为：这是什么问题呢，查看官方文档，发现是有这样的限制的回顾我们的代码，这里的分页加载数据，上拉加载，数据是放在一个for循环里去加载，数据源是一个数组对象。在加载下一页数据时，将下一页的数据拼到当前数组后面。这里是常规的做法。可以看看代码：这里可以看到，每次获取新的一页，都要重新setData新的数组，仔细想想，当这个数组到后面越来越大的时候，很容易就超出了单次设置数据超过1024kb的限制了。那么怎么解决这个问题呢，这里官方文档里面其实有提到一个注意点，既然这里是支持改变数组的某一项，那么分页的问题，可以改变为一个二维数组，还是直接看代码吧。这里的方法则暂时摆脱了单次设置数据多大的问题。当然，要是单页的数据过多，还是会出现问题的。最合适的还是对数据结构进行精简，前端不必要的数据，可以不传过来前端。写在最后，这次第一次写类似的分享，描述还是有些不清晰，以后可以多尝试这样的总结吧。"}
{"title": "利用云开发优化博客小程序（三）——生成海报功能 ", "author": "Rolan", "pub_time": "2018-10-17 00:52", "content": "欠下的生成海报的功能终于补上了周末花了点时间把小程序版博客中的生成海报的功能给完成了，对于新手的我来说遇到的问题还是挺多的，这里简单记录下坑。首先看下效果图：思路还是比较简单，主要就是利用微信提供的画布 canvas 来动态构造海报。引导用户保存至本地相册，用于分享。主要涉及小程序画布和图片相关的API，若是不太熟悉的话可以优先参考下文档。资源准备首先需要准备构成海报的一些资源，比如文章的首图，标题，需要分享的小程序码。对于文章的首图，是从腾讯云的对象存储中获取，需要在开发设置中配置好 downloadFile合法域名 ,至于为什么转战腾讯云对象存储可以参考 免费的对象存储——七牛云还是腾讯云获取图片可直接通过 wx.getImageInfo ,对应的API还是比较简单的：wx.getImageInfo({\r\n  src: url,\r\n  success (res) {\r\n    console.log(res.path)\r\n  }\r\n})至于小程序码，目前使用的是小程序本身的，暂时没有动态生成，后期会迭代。直接将小程序码上传至云存储上,获取时也比较简单：wx.cloud.downloadFile({\r\n  fileID: fileID\r\n}).then(res => {\r\n  console.log(res.tempFilePath)\r\n})最后，其他需要在海报上展现的内容，根据实际情况进行获取。生成海报资源准备完之后，就需要利用画布进行构造海报了。在wxml添加canvas元素，需要注意的是避免在页面上展示，可以将位置设置在屏幕之外，比如 top:99999rpx\r\n<view class=\"canvas-box\">\r\n  <canvas style=\"width: 600px;height: 970px;\" canvas-id=\"mycanvas\" />\r\nview>然后需要了解下canvas相关API和属性了。优先创建canvas的绘图上下文 CanvasContext 对象,然后通过CanvasContext中的属性进行绘制，最后通过 draw() 将之前在绘图上下文中的描述（路径、变形、样式）画到 canvas 中。具体可以参考下面的代码，结合注释和官方文档很容易理解：var context = wx.createCanvasContext('mycanvas');\r\n    context.setFillStyle('#ffffff');//设置填充色\r\n    context.fillRect(0, 0, 600, 970);//填充一个矩形。用 setFillStyle 设置矩形的填充色\r\n    context.drawImage(postImageLocal, 0, 0, 600, 300); //绘制首图\r\n    context.drawImage(qrcodeLoal, 210, 650, 180, 180); //绘制二维码\r\n    context.setFillStyle(\"#000000\");\r\n    context.setFontSize(20);//设置字体大小\r\n    context.setTextAlign('center');//设置字体对齐\r\n    context.fillText(\"阅读文章,请长按识别二维码\", 300, 895);\r\n    context.setFillStyle(\"#000000\");\r\n    context.beginPath() //分割线\r\n    context.moveTo(30, 620)\r\n    context.lineTo(570, 620)\r\n    context.stroke();\r\n    context.setTextAlign('left');\r\n    context.setFontSize(40);\r\n\r\n    if (title.lengh <= 12) {\r\n      context.fillText(title, 40, 360);//文章标题\r\n    } else {\r\n      context.fillText(title.substring(0, 12), 40, 360);\r\n      context.fillText(title.substring(12, 26), 40, 410);\r\n    }\r\n\r\n    context.setFontSize(20);\r\n    if (custom_excerpt.lengh <= 26) {\r\n      context.fillText(custom_excerpt, 40, 470);//文章描述\r\n    } else {\r\n      context.fillText(custom_excerpt.substring(0, 26), 40, 470);\r\n      context.fillText(custom_excerpt.substring(26, 50) + '...', 40, 510);\r\n    }\r\n\r\n    context.draw();这里需要注意的是填写文字时，画布是不会自动换行的，所以这里需要根据字体大小和字体多少来自行控制换行。在填充完canvas之后，通过 wx.canvasToTempFilePath 来生成图片，并保存在临时路径下，具体代码如下：wx.canvasToTempFilePath({\r\n  canvasId: 'mycanvas',\r\n  success: function(res) {\r\n    var tempFilePath = res.tempFilePath;\r\n    wx.hideLoading();\r\n    console.log(\"海报图片路径：\" + res.tempFilePath);\r\n    that.setData({\r\n      showPosterPopup: true,//展示弹窗\r\n      showPosterImage: res.tempFilePath //对应路径\r\n    })\r\n  },\r\n  fail: function(res) {\r\n    console.log(res);\r\n  }\r\n});到这里，最简单的海报生成完成了，接下来就是涉及交互了。交互样式首先利用zanui的 zan-popup 来实现弹出层，还是比较方便的。具体样式就不贴了，可以直接看我的源码。弹出层中加载生成好的海报图片，通过按钮引导用户保存至本地相册，在保存相册时，需要用户授权本地相册的权限，这里需要做好交互，当用户拒绝之后再次想保存时，让他重新授权。当用户取消时，再次提醒：具体代码如下，供参考：/**\r\n * 保存海报图片\r\n */\r\nsavePosterImage: function() {\r\n  let that = this\r\n  wx.saveImageToPhotosAlbum({\r\n    filePath: that.data.showPosterImage,\r\n    success(result) {\r\n      console.log(result)\r\n      wx.showModal({\r\n        title: '提示',\r\n        content: '二维码海报已存入手机相册，赶快分享到朋友圈吧',\r\n        showCancel: false,\r\n        success: function(res) {\r\n          that.setData({\r\n            showPosterPopup: false\r\n          })\r\n        }\r\n      })\r\n    },\r\n    fail: function(err) {\r\n      console.log(err);\r\n      if (err.errMsg === \"saveImageToPhotosAlbum:fail auth deny\") {\r\n        console.log(\"再次发起授权\");\r\n        wx.showModal({\r\n          title: '用户未授权',\r\n          content: '如需保存海报图片到相册，需获取授权.是否在授权管理中选中“保存到相册”?',\r\n          showCancel: true,\r\n          success: function(res) {\r\n            if (res.confirm) {\r\n              console.log('用户点击确定')\r\n              wx.openSetting({\r\n                success: function success(res) {\r\n                  console.log('打开设置', res.authSetting);\r\n                  wx.openSetting({\r\n                    success(settingdata) {\r\n                      console.log(settingdata)\r\n                      if (settingdata.authSetting['scope.writePhotosAlbum']) {\r\n                        console.log('获取保存到相册权限成功');\r\n                      } else {\r\n                        console.log('获取保存到相册权限失败');\r\n                      }\r\n                    }\r\n                  })\r\n\r\n                }\r\n              });\r\n            }\r\n          }\r\n        })\r\n      }\r\n    }\r\n  });\r\n}到这里，小程序的生成海报功能基本上就完成了。总结其实生成海报的功能还有很多小问题，由于最近项目比较紧匆匆上了，后面找时间会优化。通过生成海报的功能，主要还是学习了画布的API，并通过实战也基本可以上手canvas，至于画布上排版，样式就需要自己耐心了，尤其是一些小地方。程序上线后我才发现，海报上的标题，由于有中英文，所占的字符不同，所以换行的处理过于草率了，导致有英文的标题在位置上存在偏差。后期有空的话再持续改善吧～"}
{"title": "小程序入口构造工具&二维码测试工具 ", "author": "Rolan", "pub_time": "2018-9-25 00:28", "content": "本文将介绍我们小程序中隐藏的两个工具页面。原理虽不复杂，收益却实实在在，或许也能给诸君带来启发。入口构造工具痛点PM&运营 投放链接 PM&运营每次投放新入口时，都需要找FE要页面链接。投放多少链接就要找FE多少次，一方面相互之间的沟通等待会耗掉不少时间，另一方面询问/回复过程会打断对方手头的工作，影响状态。 关键是大多时候这些链接只是需要改个渠道参数，并不涉及结构上的调整，完全可以由PM/运营自行修改。 然而要向所有PM&运营全面科普url构造规则，并没有想象中容易；各种链接构造需求就这样在无形中不断消耗双方的精力。FE&QA 开发/测试线下功能 开发/测试没有线上入口的新功能时，经常需要构造一个临时入口供以访问。 可以修改线下接口配置运营位作为访问入口，但是一则运营位有限，二则不能一站式操作；也可以修改代码加个临时入口，但是会污染代码，难保不会带到线上。 这样的情形反复出现也是挺麻烦的。idea开发一个专门的入口构造页面，直接提供给PM、运营、FE、QA等各方使用。需要什么链接需要什么入口，直接自助生成，无需一次次反复沟通/构造。效果通用入口构造： 如图所示，在入口构造页面中，用户可以直接输入FE提供的url模板并自助修改链接参数，从而获得所需链接。同时支持：直接打开该链接，进行查看、自测；生成以该链接作为落地链接的分享卡片，从而以落地页的形式打开查看；将该链接复制到剪贴板，供以投放；生成以该链接作为落地链接的二维码，供以投放。内嵌M页入口构造： 如图所示，内嵌M页的小程序链接构造同样支持类似功能。实现需求转译 将链接参数以普通用户能理解的形式展现出来，并允许其直接修改，再配以说明文案。以此抹平url构造规则造成的技术门槛。入口构造 页内入口 直接以按钮跳转实现，外部入口 以分享卡片进行模拟。链接输出 使用wx.setClipboardData接口经由剪贴板粘贴使用。初始入口 生成二维码作为入口构造页面自身的初始入口；将工具页面分享出去，保留分享卡片作为初始入口。意义效率入口构造工具使得PM、运营、FE、QA等各方可以自助、高效地构造所需链接/入口，有效节省了重复沟通成本，并在一定程度上提高了开发、测试、投放效率。质量入口构造工具提供的链接生成功能和预览功能可以在一定程度上避免/发现链接拼接失误等人工疏漏，提高整体交付质量。二维码测试工具痛点扫描二维码时会直接进入线上版小程序，导致在开发/测试阶段难以对二维码相关功能进行有效的检测和把控。 早期只能先冒险上线，然后进行线上验证，万一有问题再修复再重新上线，导致二维码相关功能调试效率低、上线风险高。 后来开发者工具支持通过二维码编译，管理后台也支持回滚，相对来说，二维码相关功能可控性强了很多；但是对于QA、PM、运营、第三方接入业务等小伙伴来说，二维码的检查、测试还是很无力。idea开发一个专门的二维码测试页面，支持在当前开发版/体验版/线上版小程序中对二维码进行查看和预览。效果如图所示，在二维码测试页面中，用户可以：直接查看二维码的编码信息，包括落地链接、参数等；在当前开发版/体验版/线上版小程序中打开二维码落地链接；生成与二维码拥有相同落地链接的当前开发版/体验版/线上版小程序的分享卡片。实现查看二维码信息 使用wx.scanCode接口可以读取二维码信息，包括落地页、参数等。在当前开发版/体验版/线上版中打开二维码 使用wx.scanCode接口获取落地链接，使用wx.navigateTo等接口在当前开发版/体验版/线上版小程序中打开目标页面。在当前开发版/体验版/线上版中以落地页的形式打开二维码 使用wx.scanCode接口获取落地链接，生成相同落地链接的分享卡片，访问分享卡片以模拟开发版/体验版下扫码打开小程序。意义效率 查看二维码信息可以有效提高相关功能调试效率； 直接在当前开发版/体验版中打开二维码可以有效提高相关功能测试效率，特别是对于QA等非前端人员。质量 二维码测试工具便于QA在稳定环境充分测试二维码相关功能，从而提高小程序交付质量。值得一提的是，这两个工具都是FE自发思考自发实现的，产出时小伙伴们表示“很惊喜”。 很多时候，主动去思考、发现、分析、解决痛点，能让你贡献出意料之外的价值，共勉。"}
{"title": "小程序·云开发的云函数路由高级玩法 ", "author": "Rolan", "pub_time": "2018-9-25 00:38", "content": "李成熙，腾讯云高级工程师。2014年度毕业加入腾讯AlloyTeam，先后负责过QQ群、花样直播、腾讯文档等项目。2018年加入腾讯云云开发团队。专注于性能优化、工程化和小程序服务。微博 | 知乎 | Github概念回顾在掘金开发者大会上，在推荐实践那里，我有提到一种云函数的用法，我们可以将相同的一些操作，比如用户管理、支付逻辑，按照业务的相似性，归类到一个云函数里，这样比较方便管理、排查问题以及逻辑的共享。甚至如果你的小程序的后台逻辑不复杂，请求量不是特别大，完全可以在云函数里面做一个单一的微服务，根据路由来处理任务。用下面三幅图可以概括，我们来回顾一下：比如这里就是传统的云函数用法，一个云函数处理一个任务，高度解耦。第二幅架构图就是尝试将请求归类，一个云函数处理某一类的请求，比如有专门负责处理用户的，或者专门处理支付的云函数。最后一幅图显示这里只有一个云函数，云函数里有一个分派任务的路由管理，将不同的任务分配给不同的本地函数处理。tcb-router 介绍及用法为了方便大家试用，咱们腾讯云 Tencent Cloud Base 团队开发了 tcb-router，云函数路由管理库方便大家使用。那具体怎么使用 tcb-router 去实现上面提到的架构呢？下面我会逐一举例子。架构一：一个云函数处理一个任务这种架构下，其实不需要用到 tcb-router，像普通那样写好云函数，然后在小程序端调用就可以了。云函数// 函数 router\r\nexports.main = (event, context) => {\r\n    return {\r\n        code: 0,\r\n        message: 'success'\r\n    };\r\n}；小程序端wx.cloud.callFunction({\r\n      name: 'router',\r\n      data: {\r\n        name: 'tcb',\r\n        company: 'Tencent'\r\n      }\r\n    }).then((res) => {\r\n      console.log(res);\r\n    }).catch((e) => {\r\n      console.log(e);\r\n});架构二： 按请求给云函数归类此类架构就是将相似的请求归类到同一个云函数处理，比如可以分为用户管理、支付等等的云函数。云函数// 函数 user\r\nconst TcbRouter = require('tcb-router');\r\n\r\nexports.main = async (event, context) => {\r\n    const app = new TcbRouter({ event });\r\n    \r\n    app.router('register', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'register success'\r\n        }\r\n    });\r\n\r\n    app.router('login', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'login success'\r\n        }\r\n    });\r\n\r\n    return app.serve();\r\n}；\r\n\r\n// 函数 pay\r\nconst TcbRouter = require('tcb-router');\r\n\r\nexports.main = async (event, context) => {\r\n    const app = new TcbRouter({ event });\r\n    \r\n    app.router('makeOrder', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'make order success'\r\n        }\r\n    });\r\n\r\n    app.router('pay', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'pay success'\r\n        }\r\n    });\r\n\r\n    return app.serve();\r\n}；小程序端// 注册用户\r\nwx.cloud.callFunction({\r\n      name: 'user',\r\n      data: {\r\n        $url: 'register',\r\n        name: 'tcb',\r\n        password: '09876'\r\n      }\r\n    }).then((res) => {\r\n      console.log(res);\r\n    }).catch((e) => {\r\n      console.log(e);\r\n});\r\n\r\n// 下单商品\r\nwx.cloud.callFunction({\r\n      name: 'pay',\r\n      data: {\r\n        $url: 'makeOrder',\r\n        id: 'xxxx',\r\n        amount: '3'\r\n      }\r\n    }).then((res) => {\r\n      console.log(res);\r\n    }).catch((e) => {\r\n      console.log(e);\r\n});架构三： 由一个云函数处理所有服务云函数// 函数 router\r\nconst TcbRouter = require('tcb-router');\r\n\r\nexports.main = async (event, context) => {\r\n    const app = new TcbRouter({ event });\r\n    \r\n    app.router('user/register', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'register success'\r\n        }\r\n    });\r\n\r\n    app.router('user/login', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'login success'\r\n        }\r\n    });\r\n\r\n    app.router('pay/makeOrder', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'make order success'\r\n        }\r\n    });\r\n\r\n    app.router('pay/pay', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'pay success'\r\n        }\r\n    });\r\n\r\n    return app.serve();\r\n}；小程序端// 注册用户\r\nwx.cloud.callFunction({\r\n      name: 'router',\r\n      data: {\r\n        $url: 'user/register',\r\n        name: 'tcb',\r\n        password: '09876'\r\n      }\r\n    }).then((res) => {\r\n      console.log(res);\r\n    }).catch((e) => {\r\n      console.log(e);\r\n});\r\n\r\n// 下单商品\r\nwx.cloud.callFunction({\r\n      name: 'router',\r\n      data: {\r\n        $url: 'pay/makeOrder',\r\n        id: 'xxxx',\r\n        amount: '3'\r\n      }\r\n    }).then((res) => {\r\n      console.log(res);\r\n    }).catch((e) => {\r\n      console.log(e);\r\n});借鉴 Koa2 的中间件机制实现云函数的路由管理小程序·云开发的云函数目前更推荐 async/await 的玩法来处理异步操作，因此这里也参考了同样是基于 async/await 的 Koa2 的中间件实现机制。从上面的一些例子我们可以看出，主要是通过 use 和 router 两种方法传入路由以及相关处理的中间件。use 只能传入一个中间件，路由也只能是字符串，通常用于 use 一些所有路由都得使用的中间件// 不写路由表示该中间件应用于所有的路由\r\napp.use(async (ctx, next) => {\r\n\r\n});\r\n\r\napp.use('router', async (ctx, next) => {\r\n\r\n});router 可以传一个或多个中间件，路由也可以传入一个或者多个。app.router('router', async (ctx, next) => {\r\n\r\n});\r\n\r\napp.router(['router', 'timer'], async (ctx, next) => {\r\n    await next();\r\n}, async (ctx, next) => {\r\n    await next();\r\n}, async (ctx, next) => {\r\n\r\n});不过，无论是 use 还是 router，都只是将路由和中间件信息，通过 _addMiddleware 和 _addRoute 两个方法，录入到 _routerMiddlewares 该对象中，用于后续调用 serve 的时候，层层去执行中间件。最重要的运行中间件逻辑，则是在 serve 和 compose 两个方法里。serve 里主要的作用是做路由的匹配以及将中间件组合好之后，通过 compose 进行下一步的操作。比如以下这段节选的代码，其实是将匹配到的路由的中间件，以及 * 这个通配路由的中间件合并到一起，最后依次执行。let middlewares = (_routerMiddlewares[url]) ? _routerMiddlewares[url].middlewares : [];\r\n// put * path middlewares on the queue head\r\nif (_routerMiddlewares['*']) {\r\n    middlewares = [].concat(_routerMiddlewares['*'].middlewares, middlewares);\r\n}组合好中间件后，执行这一段，将中间件 compose 后并返回一个函数，传入上下文 this 后，最后将 this.body 的值 resolve，即一般在最后一个中间件里，通过对 ctx.body 的赋值，实现云函数的对小程序端的返回：const fn = compose(middlewares);\r\n\r\nreturn new Promise((resolve, reject) => {\r\n    fn(this).then((res) => {\r\n        resolve(this.body);\r\n    }).catch(reject);\r\n});那么 compose 是怎么组合好这些中间件的呢？这里截取部份代码进行分析function compose(middleware) {\r\n    /**\r\n     * ... 其它代码 \r\n     */\r\n    return function (context, next) {\r\n        // 这里的 next，如果是在主流程里，一般 next 都是空。\r\n        let index = -1;\r\n\r\n        // 在这里开始处理处理第一个中间件\r\n        return dispatch(0);\r\n\r\n        // dispatch 是核心的方法，通过不断地调用 dispatch 来处理所有的中间件\r\n        function dispatch(i) {\r\n            if (i <= index) {\r\n                return Promise.reject(new Error('next() called multiple times'));\r\n            }\r\n\r\n            index = i;\r\n\r\n            // 获取中间件函数\r\n            let handler = middleware[i];\r\n\r\n            // 处理完最后一个中间件，返回 Proimse.resolve\r\n            if (i === middleware.length) {\r\n                handler = next;\r\n            }\r\n\r\n            if (!handler) {\r\n                return Promise.resolve();\r\n            }\r\n\r\n            try {\r\n                // 在这里不断地调用 dispatch, 同时增加 i 的数值处理中间件\r\n                return Promise.resolve(handler(context, dispatch.bind(null, i + 1)));\r\n            }\r\n            catch (err) {\r\n                return Promise.reject(err);\r\n            }\r\n        }\r\n    }\r\n}看完这里的代码，其实有点疑惑，怎么通过 Promise.resolve(handler(xxxx)) 这样的代码逻辑可以推进中间件的调用呢？首先，我们知道，handler 其实就是一个 async function，next，就是 dispatch.bind(null, i + 1) 比如这个：async (ctx, next) => {\r\n    await next();\r\n}而我们知道，dispatch 是返回一个 Promise.resolve 或者一个 Promise.reject，因此在 async function 里执行 await next()，就相当于触发下一个中间件的调用。当 compose 完成后，还是会返回一个 function (context, next)，于是就走到下面这个逻辑，执行 fn 并传入上下文 this 后，再将在中间件中赋值的 this.body resolve 出来，最终就成为云函数数要返回的值。const fn = compose(middlewares);\r\n\r\nreturn new Promise((resolve, reject) => {\r\n    fn(this).then((res) => {\r\n        resolve(this.body);\r\n    }).catch(reject);\r\n});看到 Promise.resolve 一个 async function，许多人都会很困惑。其实撇除 next 这个往下调用中间件的逻辑，我们可以很好地将逻辑简化成下面这段示例：let a = async () => {\r\n    console.log(1);\r\n};\r\n\r\nlet b = async () => {\r\n    console.log(2);\r\n\r\n    return 3;\r\n};\r\n\r\n\r\nlet fn = async () => {\r\n    await a();\r\n    return b();\r\n};\r\n\r\nPromise.resolve(fn()).then((res) => {\r\n    console.log(res);\r\n});\r\n\r\n// 输出\r\n// 1\r\n// 2\r\n// 3"}
